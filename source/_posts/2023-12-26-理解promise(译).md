---
layout: post
title: C++协程：理解Promise（译）
---

# C++ Coroutines: Understanding the promise type

This post is the third in the series on the C++ Coroutines TS ([N4736](http://wg21.link/N4736)).

> 这篇博文是 C++协程 TS 系列的第三篇

The previous articles in this series cover:

> 前面的的文章包括：

- [Coroutine Theory](https://lewissbaker.github.io/2017/09/25/coroutine-theory)
- [Understanding operator co_await](https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await)

In this post I look at the mechanics of how the compiler translates coroutine code that you write into compiled code and how you can customise the behaviour of a coroutine by defining your own **Promise** type.

> 在这篇博文中我们来了解编译器是如何把你写的协程代码编程编译后的代码的，同时也了解如何通过定义自己的 Promise 类型来定制协程的行为。

## Coroutine Concepts

The Coroutines TS adds three new keywords: `co_await`, `co_yield` and `co_return`. Whenever you use one of these coroutine keywords in the body of a function this triggers the compiler to compile this function as a coroutine rather than as a normal function.

The compiler applies some fairly mechanical transformations to the code that you write to turn it into a state-machine that allows it to suspend execution at particular points within the function and then later resume execution.

In the previous post I described the first of two new interfaces that the Coroutines TS introduces: The **Awaitable** interface. The second interface that the TS introduces that is important to this code transformation is the **Promise** interface.

The **Promise** interface specifies methods for customising the behaviour of the coroutine itself. The library-writer is able to customise what happens when the coroutine is called, what happens when the coroutine returns (either by normal means or via an unhandled exception) and customise the behaviour of any `co_await` or `co_yield` expression within the coroutine.

> 协程 TS 新增了三个关键字：`co_await`，`co_yield`，`co_return`。每当你在函数体中使用了协程关键字的其中一个，就会触发编译器将这个函数编译为一个协程而不是普通函数。
>
> 编译器会进行一些相当机械的变换，将你的代码变成一个状态机。这个状态机可以在函数的特定点上暂停并在之后恢复。
>
> 在之前的博文中，我描述了协程 TS 的两个接口中的第一个：Awaitable 接口；而协程 TS 引入的第二个接口、也是对代码变换非常重要的接口是 Promise 接口。
>
> Promise 接口给出了定制协程行为的方法。库作者可以自定义在协程调用时会发生什么，在协程返回（要么是通过正常途径或者通过未处理的异常）时会发生什么，也会自定义协程中的`co_await`或者`co_yield`表达式的行为。

## Promise objects

The **Promise** object defines and controls the behaviour of the coroutine itself by implementing methods that are called at specific points during execution of the coroutine.

> Promise 对象通过实现一些方法以定义并控制协程的行为，这些方法会在协程运行中的特定点上被调用。

> Before we go on, I want you to try and rid yourself of any preconceived notions of what a “promise” is. While, in some use-cases, the coroutine promise object does indeed act in a similar role to the `std::promise` part of a `std::future` pair, for other use-cases the analogy is somewhat stretched. It may be easier to think about the coroutine’s promise object as being a “coroutine state controller” object that controls the behaviour of the coroutine and can be used to track its state.
>
> > 在我们继续之前，我想让你试着摆脱任何关于“promise”的先入为主的观念。虽然在某些用例中，协程 promise 对象确实扮演了与`std::future`对中的`std::promise`部分类似的角色，但对于其他用例，这种类比有些延伸（指这种类比并不恰当）。将协程的 promise 对象看作是一个“协程状态控制器”对象可能更容易，它控制协程的行为，并可用于跟踪其状态。

An instance of the promise object is constructed within the coroutine frame for each invocation of a coroutine function.

The compiler generates calls to certain methods on the promise object at key points during execution of the coroutine.

In the following examples, assume that the promise object created in the coroutine frame for a particular invocation of the coroutine is `promise`.

When you write a coroutine function that has a body, `<body-statements>`, which contains one of the coroutine keywords (`co_return`, `co_await`, `co_yield`) then the body of the coroutine is transformed to something (roughly) like the following:

> 每次调用协程函数时，都会在协程帧内构建一个 promise 对象实例。
>
> 编译器会在执行协程的关键时刻生成对 promise 对象上某些方法的调用。
>
> 在下面的示例中，假设在协程帧中为特定的协程调用创建的 promise 对象是 `promise`。
>
> 当你编写的协程函数的主体`<body-statements>`包含一个协程关键字（`co_return`、`co_await`、`co_yield`）时，协程的主体会被转换成类似下面的内容（大致如此）：

```c++
{
  co_await promise.initial_suspend();
  try
  {
    <body-statements>
  }
  catch (...)
  {
    promise.unhandled_exception();
  }
FinalSuspend:
  co_await promise.final_suspend();
}
```

When a coroutine function is called there are a number of steps that are performed prior to executing the code in the source of the coroutine body that are a little different to regular functions.

> 当调用一个 coroutine 函数时，在执行 coroutine 主体源代码之前会执行一些步骤，这些步骤与普通函数有些不同。

Here is a summary of the steps (I’ll go into more detail on each of the steps below).

1. Allocate a coroutine frame using `operator new` (optional).
2. Copy any function parameters to the coroutine frame.
3. Call the constructor for the promise object of type, `P`.
4. Call the `promise.get_return_object()` method to obtain the result to return to the caller when the coroutine first suspends. Save the result as a local variable.
5. Call the `promise.initial_suspend()` method and `co_await` the result.
6. When the `co_await promise.initial_suspend()` expression resumes (either immediately or asynchronously), then the coroutine starts executing the coroutine body statements that you wrote.

> 以下是步骤摘要（我将在下文中详细介绍每个步骤）。
>
> 1. 使用 `operator new` 分配一个 coroutine 框架（可选）。
> 2. 将函数参数复制到协程帧中。
> 3. 调用 `P` 类型的 promise 对象的构造函数。
> 4. 调用 `promise.get_return_object()` 方法获取结果，以便在 coroutine 首次暂停时返回给调用者。将结果保存为本地变量。
> 5. 调用 `promise.initial_suspend()` 方法并 `co_await` 结果。
> 6. 当 `co_await promise.initial_suspend()` 表达式恢复（立即恢复或异步恢复）时，coroutine 开始执行您编写的 coroutine 主体语句。

Some additional steps are executed when execution reaches a `co_return` statement:

1. Call `promise.return_void()` or `promise.return_value(<expr>)`
2. Destroy all variables with automatic storage duration in reverse order they were created.
3. Call `promise.final_suspend()` and `co_await` the result.

> 当执行到 "co_return "语句时，会执行一些额外的步骤：
>
> 1. 调用 `promise.return_void()` 或 `promise.return_value(<expr>)`
> 2. 按创建时的相反顺序销毁所有自动存储期限的变量。
> 3. 调用 `promise.final_suspend()` 并等待结果。

If instead, execution leaves `<body-statements>` due to an unhandled exception then:

1. Catch the exception and call `promise.unhandled_exception()` from within the catch-block.
2. Call `promise.final_suspend()` and `co_await` the result.

> 相反，如果由于未处理的异常而导致执行离开`<body-statements>`，则
>
> 1. 捕获异常并在捕获块中调用 `promise.unhandled_exception()`。
> 2. 调用 `promise.final_suspend()` 并等待结果。

Once execution propagates outside of the coroutine body then the coroutine frame is destroyed. Destroying the coroutine frame involves a number of steps:

1. Call the destructor of the promise object.
2. Call the destructors of the function parameter copies.
3. Call `operator delete` to free the memory used by the coroutine frame (optional)
4. Transfer execution back to the caller/resumer.

> 一旦执行传播到了协程主体之外，协程帧就会被销毁。销毁协程帧涉及多个步骤：
>
> 1. 调用 promise 对象的析构函数。
> 2. 调用函数参数副本的析构函数。
> 3. 调用 `operator delete` 释放由协程帧使用的内存（可选）
> 4. 将执行转回调用者/恢复者。

When execution first reaches a `<return-to-caller-or-resumer>` point inside a `co_await` expression, or if the coroutine runs to completion without hitting a `<return-to-caller-or-resumer>` point, then the coroutine is either suspended or destroyed and the return-object previously returned from the call to `promise.get_return_object()` is then returned to the caller of the coroutine.

> 当协程首次运行到达`co_await`表达式中的`<return-to-caller-or-resumer>`点时、或者如果协程运行到完成而没有到达`<return-to-caller-or-resumer>`点时，那么协程将被暂停或销毁，之前通过调用`promise.get_return_object()`返回的返回对象将返回给协程的调用者。

### Allocating a coroutine frame

First, the compiler generates a call to `operator new` to allocate memory for the coroutine frame.

If the promise type, `P`, defines a custom `operator new` method then that is called, otherwise the global `operator new` is called.

There are a few important things to note here:

The size passed to `operator new` is not `sizeof(P)` but is rather the size of the entire coroutine frame and is determined automatically by the compiler based on the number and sizes of parameters, size of the promise object, number and sizes of local variables and other compiler-specific storage needed for management of coroutine state.

> 首先，编译器会调用 `operator new` 为协程帧分配内存。
>
> 如果 promise 类型 `P` 定义了自定义的 `operator new` 方法，则调用该方法，否则调用全局的 `operator new` 方法。
>
> 这里有几件重要的事情需要注意：
>
> 传递给 `operator new` 的大小不是 `sizeof(P)` 而是整个程序框架的大小，由编译器根据参数的数量和大小、promise 对象的大小、局部变量的数量和大小以及管理程序状态所需的其他编译器特定存储空间自动确定。

The compiler is free to elide the call to `operator new` as an optimisation if:

- it is able to determine that the lifetime of the coroutine frame is strictly nested within the lifetime of the caller; and
- the compiler can see the size of coroutine frame required at the call-site.

> 在以下情况下，编译器可以自由地省略对 `operator new`的调用，对代码进行优化：
>
> - 编译器能够确定协程帧的生命周期严格嵌套在调用者的生命周期内；
> - 编译器可以看到调用位置所需的协程帧大小。

In these cases, the compiler can allocate storage for the coroutine frame in the caller’s activation frame (either in the stack-frame or coroutine-frame part).

The Coroutines TS does not yet specify any situations in which the allocation elision is guaranteed, so you still need to write code as if the allocation of the coroutine frame may fail with `std::bad_alloc`. This also means that you usually shouldn’t declare a coroutine function as `noexcept` unless you are ok with `std::terminate()` being called if the coroutine fails to allocate memory for the coroutine frame.

> 在这种情况下，编译器可以在调用者的活动帧（堆栈帧或例程帧部分）中为例程帧分配存储空间。
>
> 目前，Coroutines TS 还没有规定任何可以保证分配忽略的情况，因此在编写代码时，仍需考虑到在分配 coroutine 框架时可能会出现 `std::bad_alloc`，从而导致分配失败。这也意味着您通常不应将协程函数声明为 `noexcept`，除非您可以接受在为协程帧分配内存失败时调用 `std::termininate()`。

There is a fallback, however, that can be used in lieu of exceptions for handling failure to allocate the coroutine frame. This can be necessary when operating in environments where exceptions are not allowed, such as embedded environments or high-performance environments where the overhead of exceptions is not tolerated.

If the promise type provides a static `P::get_return_object_on_allocation_failure()` member function then the compiler will generate a call to the `operator new(size_t, nothrow_t)` overload instead. If that call returns `nullptr` then the coroutine will immediately call `P::get_return_object_on_allocation_failure()` and return the result to the caller of the coroutine instead of throwing an exception.

> 不过，在分配协程帧失败时，可以使用一种后备方法来代替异常。在不允许使用异常的环境中运行时，例如嵌入式环境或不能容忍异常开销的高性能环境，这可能是必要的。
>
> 如果 promise 类型提供了静态的 `P::get_return_object_on_allocation_failure()` 成员函数，那么编译器将生成对 `operator new(size_t, nothrow_t)` 重载的调用。如果调用返回 `nullptr`，则例程将立即调用 `P::get_return_object_on_allocation_failure()` 并将结果返回给例程的调用者，而不是抛出异常。

#### Customising coroutine frame memory allocation

Your promise type can define an overload of `operator new()` that will be called instead of global-scope `operator new` if the compiler needs to allocate memory for a coroutine frame that uses your promise type.

> 如果编译器需要为使用了您的 promise 类型的 coroutine 框架分配内存，您的 promise 类型可以定义一个 `operator new()` 的重载，它将代替全局范围的 `operator new` 被调用。

For example:

```c++
struct my_promise_type
{
  void* operator new(std::size_t size)
  {
    void* ptr = my_custom_allocate(size);
    if (!ptr) throw std::bad_alloc{};
    return ptr;
  }

  void operator delete(void* ptr, std::size_t size)
  {
    my_custom_free(ptr, size);
  }

  ...
};
```

“But what about custom allocators?”, I hear you asking.

You can also provide an overload of `P::operator new()` that takes additional arguments which will be called with lvalue references to the coroutine function parameters if a suitable overload can be found. This can be used to hook up `operator new` to call an `allocate()` method on an allocator that was passed as an argument to the coroutine function.

You will need to do some extra work to make a copy of the allocator inside the allocated memory so you can reference it in the corresponding call to `operator delete` since the parameters are not passed to the corresponding `operator delete` call. This is because the parameters are stored in the coroutine-frame and so they will have already been destructed by the time that `operator delete` is called.

For example, you can implement `operator new` so that it allocates extra space after the coroutine frame and use that space to stash a copy of the allocator that can be used to free the coroutine frame memory.

> 我听到你在问："但自定义分配器怎么办"？
>
> 你也可以提供一个 `P::operator new()` 的重载，该重载会接受额外的参数，这些参数是协程函数参数的左值引用，如果能找到合适的重载，它将会被调用。这可以用来 hook 掉`operator new`，你可以在重载方法中来调用分配器的`allocate()` 方法，这个分配器是作为协程函数的参数传递过来的。
>
> 由于参数没有传递给相应的 `operator delete` 调用，因此需要做一些额外的工作，在分配的内存中复制分配器，以便在相应的 `operator delete` 调用中引用它。这是因为参数存储在协程帧中，所以在调用 `operator delete` 时，它们已经被销毁了。
>
> 例如，你可以实现 `operator new` 使其在协程帧之后分配额外的空间，并使用该空间来存储分配器的副本，该副本可用于释放协程帧内存。

For example:

```c++
template<typename ALLOCATOR>
struct my_promise_type
{
  template<typename... ARGS>
  void* operator new(std::size_t sz, std::allocator_arg_t, ALLOCATOR& allocator, ARGS&... args)
  {
    // Round up sz to next multiple of ALLOCATOR alignment
    std::size_t allocatorOffset =
      (sz + alignof(ALLOCATOR) - 1u) & ~(alignof(ALLOCATOR) - 1u);

    // Call onto allocator to allocate space for coroutine frame.
    void* ptr = allocator.allocate(allocatorOffset + sizeof(ALLOCATOR));

    // Take a copy of the allocator (assuming noexcept copy constructor here)
    new (((char*)ptr) + allocatorOffset) ALLOCATOR(allocator);

    return ptr;
  }

  void operator delete(void* ptr, std::size_t sz)
  {
    std::size_t allocatorOffset =
      (sz + alignof(ALLOCATOR) - 1u) & ~(alignof(ALLOCATOR) - 1u);

    ALLOCATOR& allocator = *reinterpret_cast<ALLOCATOR*>(
      ((char*)ptr) + allocatorOffset);

    // Move allocator to local variable first so it isn't freeing its
    // own memory from underneath itself.
    // Assuming allocator move-constructor is noexcept here.
    ALLOCATOR allocatorCopy = std::move(allocator);

    // But don't forget to destruct allocator object in coroutine frame
    allocator.~ALLOCATOR();

    // Finally, free the memory using the allocator.
    allocatorCopy.deallocate(ptr, allocatorOffset + sizeof(ALLOCATOR));
  }
}
```

To hook up the custom `my_promise_type` to be used for coroutines that pass `std::allocator_arg` as the first parameter, you need to specialise the `coroutine_traits` class (see section on `coroutine_traits` below for more details).

> 要将自定义的 `my_promise_type` 挂接到以 `std::allocator_arg` 为第一个参数的协程函数上，需要对 `coroutine_traits` 类进行特殊化（详见下面的 `coroutine_traits` 章节）。

For example:

```c++
namespace std::experimental
{
  template<typename ALLOCATOR, typename... ARGS>
  struct coroutine_traits<my_return_type, std::allocator_arg_t, ALLOCATOR, ARGS...>
  {
    using promise_type = my_promise_type<ALLOCATOR>;
  };
}
```

Note that even if you customise the memory allocation strategy for a coroutine, **the compiler is still allowed to elide the call to your memory allocator**.

> 请注意，即使您为一个协程定制了内存分配策略，**编译器仍可省略对内存分配器的调用**。

### Copying parameters to the coroutine frame

The coroutine needs to copy any parameters passed to the coroutine function by the original caller into the coroutine frame so that they remain valid after the coroutine is suspended.

If parameters are passed to the coroutine by value, then those parameters are copied to the coroutine frame by calling the type’s move-constructor.

If parameters are passed to the coroutine by reference (either lvalue or rvalue), then only the references are copied into the coroutine frame, not the values they point to.

Note that for types with trivial destructors, the compiler is free to elide the copy of the parameter if the parameter is never referenced after a reachable `<return-to-caller-or-resumer>` point in the coroutine.

> 协程需要将原始调用者传递给协程函数的任何参数复制到协程帧中，以便这些参数在协程暂停后仍然有效。
>
> 如果参数是通过值传递给 coroutine 的，那么这些参数将通过调用类型的 move-constructor 复制到 coroutine 框架中。
>
> 如果参数通过引用（lvalue 或 rvalue）传递给协程，那么只有引用被复制到协程帧，而不是它们指向的值。
>
> 需要注意的是，对于具有平凡析构函数的类型，如果在程序中的`<return-to-caller-or-resumer>`点之后不再引用参数，编译器就可以省略参数的复制。

There are many gotchas involved when passing parameters by reference into coroutines as you cannot necessarily rely on the reference remaining valid for the lifetime of the coroutine. Many common techniques used with normal functions, such as perfect-forwarding and universal-references, can result in code that has undefined behaviour if used with coroutines. Toby Allsopp has written a [great article](https://toby-allsopp.github.io/2017/04/22/coroutines-reference-params.html) on this topic if you want more details.

If any of the parameter copy/move constructors throws an exception then any parameters already constructed are destructed, the coroutine frame is freed and the exception propagates back out to the caller.

> 通过引用将参数传递到例行程序时会遇到很多麻烦，因为你不一定能依赖引用在例行程序的生命周期内保持有效。许多用于普通函数的常用技术，如完美转发（perfect-forwarding）和通用引用（universal-references），如果用于例行程序，可能会导致代码出现未定义的行为。如果你想了解更多细节，Toby Allsopp 写了一篇关于这个主题的[精彩文章](https://toby-allsopp.github.io/2017/04/22/coroutines-reference-params.html)。
>
> 如果任何一个参数复制/移动构造函数抛出异常，那么任何已经构造好的参数都会被析构，协程帧被释放，异常会传播回调用者。

### Constructing the promise object

Once all of the parameters have been copied into the coroutine frame, the coroutine then constructs the promise object.

The reason the parameters are copied prior to the promise object being constructed is to allow the promise object to be given access to the post-copied parameters in its constructor.

First, the compiler checks to see if there is an overload of the promise constructor that can accept lvalue references to each of the copied parameters. If the compiler finds such an overload then the compiler generates a call to that constructor overload. If it does not find such an overload then the compiler falls back to generating a call to the promise type’s default constructor.

Note that the ability for the promise constructor to “peek” at the parameters was a relatively recent change to the Coroutines TS, being adopted in [N4723](http://wg21.link/N4723) at the Jacksonville 2018 meeting. See [P0914R1](http://wg21.link/P0914R1) for the proposal. Thus it may not be supported by some older versions of Clang or MSVC.

If the promise constructor throws an exception then the parameter copies are destructed and the coroutine frame freed during stack unwinding before the exception propagates out to the caller.

> 将所有参数复制到协程帧后，例程就会构造 promise 对象。
>
> 之所以在构造 promise 对象之前复制参数，是为了允许 promise 对象在其构造函数中访问复制后的参数。
>
> 首先，编译器会检查 promise 构造函数的重载是否可以接受对每个复制参数的 lvalue 引用。如果编译器找到这样的重载，就会生成对该构造函数重载的调用。如果没有找到这样的重载，编译器就会退回到生成对 promise 类型默认构造函数的调用。
>
> 请注意，promise 构造函数 "偷看 "参数的功能是 Coroutines TS 最近才做出的修改，在杰克逊维尔 2018 年会议上被 [N4723](http://wg21.link/N4723) 采纳。有关提案，请参见 [P0914R1](http://wg21.link/P0914R1)。因此，某些旧版本的 Clang 或 MSVC 可能不支持它。
>
> 如果 promise 构造函数抛出异常，那么在异常传播到调用者之前，会在堆栈解开过程中析构参数副本并释放 coroutine 框架。

### Obtaining the return object

The first thing a coroutine does with the promise object is obtain the `return-object` by calling `promise.get_return_object()`.

The `return-object` is the value that is returned to the caller of the coroutine function when the coroutine first suspends or after it runs to completion and execution returns to the caller.

You can think of the control flow going something (very roughly) like this:

> 通过调用 `promise.get_return_object()`，coroutine 对 promise 对象做的第一件事就是获取 `return-object` 。
>
> 返回对象 "是在 coroutine 首次暂停或运行完成后返回给调用者的值。
>
> 你可以把控制流想象成这样（非常粗略）：

```C++
// Pretend there's a compiler-generated structure called 'coroutine_frame'
// that holds all of the state needed for the coroutine. It's constructor
// takes a copy of parameters and default-constructs a promise object.
struct coroutine_frame { ... };

T some_coroutine(P param)
{
  auto* f = new coroutine_frame(std::forward<P>(param));

  auto returnObject = f->promise.get_return_object();

  // Start execution of the coroutine body by resuming it.
  // This call will return when the coroutine gets to the first
  // suspend-point or when the coroutine runs to completion.
  coroutine_handle<decltype(f->promise)>::from_promise(f->promise).resume();

  // Then the return object is returned to the caller.
  return returnObject;
}
```

Note that we need to obtain the return-object before starting the coroutine body since the coroutine frame (and thus the promise object) may be destroyed prior to the call to `coroutine_handle::resume()` returning, either on this thread or possibly on another thread, and so it would be unsafe to call `get_return_object()` after starting execution of the coroutine body.

> 请注意，我们需要在启动例程主体之前获取返回对象，因为在调用 `coroutine_handle::resume()` 返回之前，协程帧（以及 promise 对象）可能会被销毁，这可能发生在本线程上，也可能发生在其他线程上，因此在开始执行例程主体之后调用 `get_return_object()` 是不安全的。

### The initial-suspend point

The next thing the coroutine executes once the coroutine frame has been initialised and the return object has been obtained is execute the statement `co_await promise.initial_suspend();`.

This allows the author of the `promise_type` to control whether the coroutine should suspend before executing the coroutine body that appears in the source code or start executing the coroutine body immediately.

If the coroutine suspends at the initial suspend point then it can be later resumed or destroyed at a time of your choosing by calling `resume()` or `destroy()` on the coroutine’s `coroutine_handle`.

The result of the `co_await promise.initial_suspend()` expression is discarded so implementations should generally return `void` from the `await_resume()` method of the awaiter.

> 一旦初始化了协程帧并获得了返回对象，例程接下来要做的事情就是执行语句 `co_await promise.initial_suspend();`。
>
> 这样，`promise_type` 的作者就可以控制，是在执行源代码中出现的例程主体之前暂停例程，还是立即开始执行例程主体。
>
> 如果例程在初始挂起点挂起，那么以后可以通过调用例程的 `coroutine_handle` 上的 `resume()` 或 `destroy()` 来恢复或销毁例程。
>
> 由于 `co_await promise.initial_suspend()` 表达式的结果会被丢弃，因此实现时通常应从 Awaiter 的 `await_resume()` 方法中返回 `void`。

It is important to note that this statement exists outside of the `try`/`catch` block that guards the rest of the coroutine (scroll back up to the definition of the coroutine body if you’ve forgotten what it looks like). This means that any exception thrown from the `co_await promise.initial_suspend()` evaluation prior to hitting its `<return-to-caller-or-resumer>` will be thrown back to the caller of the coroutine after destroying the coroutine frame and the return object.

Be aware of this if your `return-object` has RAII semantics that destroy the coroutine frame on destruction. If this is the case then you want to make sure that `co_await promise.initial_suspend()` is `noexcept` to avoid double-free of the coroutine frame.

> 需要注意的是，该语句存在于保护例程其余部分的 `try`/`catch` 块之外（如果你忘记了它的样子，请返回例程主体的定义）。这就意味着，在执行 `<return-to-caller-or-resumer>` 之前，从 `co_await promise.initial_suspend()` 评估中抛出的任何异常都会在销毁 coroutine 框架和返回对象后被抛回给 coroutine 的调用者。
>
> 如果您的 `return-object` 具有 RAII 语义，会在销毁时销毁协程帧，那么请注意这一点。如果是这种情况，则应确保 `co_await promise.initial_suspend()` 是 `noexcept` 以避免对协程帧的双重释放。

> Note that there is a proposal to tweak the semantics so that either all or part of the `co_await promise.initial_suspend()` expression lies inside try/catch block of the coroutine-body so the exact semantics here are likely to change before coroutines are finalised.
>
> > 请注意，有人建议调整语义，使 `co_await promise.initial_suspend()` 表达式的全部或部分位于 coroutine-body 的 try/catch 块中，因此在最终确定 coroutine 之前，这里的确切语义可能会发生变化。

For many types of coroutine, the `initial_suspend()` method either returns `std::experimental::suspend_always` (if the operation is lazily started) or `std::experimental::suspend_never` (if the operation is eagerly started) which are both `noexcept` awaitables so this is usually not an issue.

> 对于许多类型的 coroutine，"initial_suspend() "方法要么返回 "std::experimental::suspend_always"（如果操作是懒散地启动的），要么返回 "std::experimental::suspend_never"（如果操作是急切地启动的），它们都是 "no-except "awaitable，因此这通常不是问题。

### Returning to the caller

When the coroutine function reaches its first `<return-to-caller-or-resumer>` point (or if no such point is reached then when execution of the coroutine runs to completion) then the `return-object` returned from the `get_return_object()` call is returned to the caller of the coroutine.

> 当例行程序函数到达其第一个 `<return-to-caller-or-resumer>` 点时（或如果没有到达该点，则当例行程序执行完毕时），从 `get_return_object()` 调用中返回的 `return-object` 将返回给例行程序的调用者。

Note that the type of the `return-object` doesn’t need to be the same type as the return-type of the coroutine function. An implicit conversion from the `return-object` to the return-type of the coroutine is performed if necessary.

> 请注意，"返回对象 "的类型不必与协程函数的返回类型相同。如果有必要，将执行从 `return-object` 到协程返回类型的隐式转换。

> Note that Clang’s implementation of coroutines (as of 5.0) defers executing this conversion until the return-object is returned from the coroutine call, whereas MSVC’s implementation as of 2017 Update 3 performs the conversion immediately after calling `get_return_object()`. Although the Coroutines TS is not explicit on the intended behaviour, I believe MSVC has plans to change their implementation to behave more like Clang’s as this enables some [interesting use cases](https://github.com/toby-allsopp/coroutine_monad).
>
> > 请注意，Clang 的协程实现（截至 5.0）会推迟执行此转换，直到从协程调用返回 return-object，而 MSVC 的实现（截至 2017 Update 3）会在调用 `get_return_object()` 后立即执行转换。虽然 Coroutines TS 没有明确说明预期的行为，但我相信 MSVC 已计划改变其实现，使其行为更像 Clang 的实现，因为这可以实现一些[有趣的用例](https://github.com/toby-allsopp/coroutine_monad)。

### Returning from the coroutine using `co_return`

When the coroutine reaches a `co_return` statement, it is translated into either a call to `promise.return_void()` or `promise.return_value(<expr>)` followed by a `goto FinalSuspend;`.

> 当协程到达一个 `co_return`语句时，它会被转换为对 `promise.return_void()` 或 `promise.return_value(<expr>)` 的调用，然后是一个 `goto FinalSuspend;`。

The rules for the translation are as follows:

- `co_return;`
  -> `promise.return_void();`
- `co_return <expr>;`
  -> `<expr>; promise.return_void();` if `<expr>` has type `void`
  -> `promise.return_value(<expr>);` if `<expr>` does not have type `void`

> 翻译规则如下：
>
> - `co_return;
-> `promise.return_void();
> - `co_return <expr>;` -> `<expr>; promise.return_void();`
>   -> `<expr>; promise.return_void();` 如果 `<expr>` 类型为 `void`
>   ->`promise.return_value(<expr>);`如果`<expr>`没有`void`类型

The subsequent `goto FinalSuspend;` causes all local variables with automatic storage duration to be destructed in reverse order of construction before then evaluating `co_await promise.final_suspend();`.

> 随后的 `goto FinalSuspend;`会导致所有具有自动存储期限的局部变量按照构造的相反顺序被销毁，然后再评估 `co_await promise.final_suspend()`;

Note that if execution runs off the end of a coroutine without a `co_return` statement then this is equivalent to having a `co_return;` at the end of the function body. In this case, if the `promise_type` does not have a `return_void()` method then the behaviour is undefined.

If either the evaluation of `<expr>` or the call to `promise.return_void()` or `promise.return_value()` throws an exception then the exception still propagates to `promise.unhandled_exception()` (see below).

> 需要注意的是，如果在协程末尾执行时没有使用 `co_return`语句，那么这就等同于在函数体末尾使用了 `co_return;`。在这种情况下，如果 `promise_type` 没有 `return_void()` 方法，那么行为就是未定义的。
>
> 如果在计算 `<expr>` 或调用 `promise.return_void()` 或 `promise.return_value()` 时出现异常，异常仍会传播到 `promise.unhandled_exception()` （见下文）

### Handling exceptions that propagate out of the coroutine body

If an exception propagates out of the coroutine body then the exception is caught and the `promise.unhandled_exception()` method is called inside the `catch` block.

Implementations of this method typically call `std::current_exception()` to capture a copy of the exception to store it away to be later rethrown in a different context.

Alternatively, the implementation could immediately rethrow the exception by executing a `throw;` statement. For example see [folly::Optional](https://github.com/facebook/folly/blob/4af3040b4c2192818a413bad35f7a6cc5846ed0b/folly/Optional.h#L587) However, doing so will (likely - see below) cause the the coroutine frame to be immediately destroyed and for the exception to propagate out to the caller/resumer. This could cause problems for some abstractions that assume/require the call to `coroutine_handle::resume()` to be `noexcept`, so you should generally only use this approach when you have full control over who/what calls `resume()`.

> 如果异常从协程主体传播出去，异常就会被捕获，并在 "catch "块内调用 "promise.unhandled_exception() "方法。
>
> 该方法的实现通常会调用 `std::current_exception()` 来捕获异常的副本并将其存储起来，以便以后在不同的上下文中重新抛出。
>
> 或者，实现可以通过执行 `throw;` 语句立即重新抛出异常。例如，请参阅 [folly::Optional](https://github.com/facebook/folly/blob/4af3040b4c2192818a413bad35f7a6cc5846ed0b/folly/Optional.h#L587)。不过，这样做会（很可能--请参阅下文）导致协程帧被立即销毁，并使异常传播到调用者/用户。这可能会给某些假定/要求调用 `coroutine_handle::resume()` 为 `noexcept` 的抽象带来问题，因此一般只有在完全控制了谁/什么调用了 `resume()` 时才使用这种方法。

Note that the current [Coroutines TS](http://wg21.link/N4736) wording is a [little unclear](https://github.com/GorNishanov/CoroutineWording/issues/17) on the intended behaviour if the call to `unhandled_exception()` rethrows the exception (or for that matter if any of the logic outside of the try-block throws an exception).

My current interpretation of the wording is that if control exits the coroutine-body, either via exception propagating out of `co_await promise.initial_suspend()`, `promise.unhandled_exception()` or `co_await promise.final_suspend()` or by the coroutine running to completion by `co_await p.final_suspend()` completing synchronously then the coroutine frame is automatically destroyed before execution returns to the caller/resumer. However, this interpretation has its own issues.

A future version of the Coroutines specification will hopefully clarify the situation. However, until then I’d stay away from throwing exceptions out of `initial_suspend()`, `final_suspend()` or `unhandled_exception()`. Stay tuned!

> 请注意，如果调用`unhandled_exception()`重新抛出异常（或者 try 块之外的任何逻辑抛出异常），当前的 [Coroutines TS](http://wg21.link/N4736) 措辞对预期行为有[一点不清楚](https://github.com/GorNishanov/CoroutineWording/issues/17)。
>
> 我目前对该措辞的解释是，如果控制退出了协程主体，无论是通过异常从 `co_await promise.initial_suspend()`、`promise.unhandled_exception()` 或 `co_await promise.final_suspend()`传播出去，还是通过 `co_await p.final_suspend()`同步完成协程运行，那么在执行返回给调用者/用户之前，协程帧会被自动销毁。然而，这种解释有其自身的问题。
>
> 希望未来版本的协程规范能澄清这种情况。不过，在此之前，我还是建议不要从 `initial_suspend()`, `final_suspend()` 或 `unhandled_exception()` 中抛出异常。敬请期待！

### The final-suspend point

Once execution exits the user-defined part of the coroutine body and the result has been captured via a call to `return_void()`, `return_value()` or `unhandled_exception()` and any local variables have been destructed, the coroutine has an opportunity to execute some additional logic before execution is returned back to the caller/resumer.

The coroutine executes the `co_await promise.final_suspend();` statement.

This allows the coroutine to execute some logic, such as publishing a result, signalling completion or resuming a continuation. It also allows the coroutine to optionally suspend immediately before execution of the coroutine runs to completion and the coroutine frame is destroyed.

> 一旦执行退出了协程主体的用户自定义部分，并且通过调用 `return_void()`、 `return_value()` 或 `unhandled_exception()` 捕获了结果，并且析构了任何局部变量，协程就有机会在执行返回给调用者/用户之前执行一些附加逻辑。
>
> 协程执行 `co_await promise.final_suspend();` 语句。
>
> 这允许协程执行一些逻辑，如发布结果、发出完成信号或恢复继续。它还允许协程在执行完成并销毁协程帧之前立即挂起。

Note that it is undefined behaviour to `resume()` a coroutine that is suspended at the `final_suspend` point. The only thing you can do with a coroutine suspended here is `destroy()` it.

The rationale for this limitation, according to Gor Nishanov, is that this provides several optimisation opportunities for the compiler due to the reduction in the number of suspend states that need to be represented by the coroutine and a potential reduction in the number of branches required.

Note that while it is allowed to have a coroutine not suspend at the `final_suspend` point, **it is recommended that you structure your coroutines so that they do suspend at `final_suspend`** where possible. This is because this forces you to call `.destroy()` on the coroutine from outside of the coroutine (typically from some RAII object destructor) and this makes it much easier for the compiler to determine when the scope of the lifetime of the coroutine-frame is nested inside the caller. This in turn makes it much more likely that the compiler can elide the memory allocation of the coroutine frame.

> 需要注意的是，恢复在 "final_suspend "点暂停的协程是未定义的行为。对于在此暂停的协程，你唯一能做的就是`destroy()`它。
>
> 戈尔-尼尚诺夫（Gor Nishanov）认为，这一限制的理由是，由于减少了协程需要表示的挂起状态数量，并可能减少所需的分支数量，这为编译器提供了若干优化机会。
>
> 请注意，虽然允许协程不在 "final_suspend "点挂起，但**建议您尽可能将协程结构设计为在 "final_suspend "点挂起。**这是因为这将迫使您从协程外部（通常是从某个 RAII 对象的析构函数）调用协程上的 `.destroy()`，这将使编译器更容易确定协程帧的生命周期范围何时嵌套在调用者内部。这反过来又使得编译器更有可能省略协程帧的内存分配。

### How the compiler chooses the promise type

So lets look now at how the compiler determines what type of promise object to use for a given coroutine.

The type of the promise object is determined from the signature of the coroutine by using the `std::experimental::coroutine_traits` class.

If you have a coroutine function with signature:

> 现在让我们来看看编译器是如何确定给定协程使用哪种类型的许诺对象的。
>
> 通过使用 `std::experimental::coroutine_traits` 类，可以根据协程的签名确定 promise 对象的类型。
>
> 如果您的协程函数签名为

```
task<float> foo(std::string x, bool flag);
```

Then the compiler will deduce the type of the coroutine’s promise by passing the return-type and parameter types as template arguments to `coroutine_traits`.

> 然后，编译器将通过把返回类型和参数类型作为模板参数传递给 `coroutine_traits` 来推断协程的 promise 类型。

```
typename coroutine_traits<task<float>, std::string, bool>::promise_type;
```

If the function is a non-static member function then the class type is passed as the second template parameter to `coroutine_traits`. Note that if your method is overloaded for rvalue-references then the second template parameter will be an rvalue reference.

For example, if you have the following methods:

> 如果函数是一个非静态成员函数，那么类类型将作为第二个模板参数传递给 `coroutine_traits`。请注意，如果您的方法重载了 右值引用，那么第二个模板参数将是一个右值引用。
>
> 例如，如果您有以下方法：

```
task<void> my_class::method1(int x) const;
task<foo> my_class::method2() &&;
```

Then the compiler will use the following promise types:

> 随后，编译器会使用如下得 promise 类型

```
// method1 promise type
typename coroutine_traits<task<void>, const my_class&, int>::promise_type;

// method2 promise type
typename coroutine_traits<task<foo>, my_class&&>::promise_type;
```

The default definition of `coroutine_traits` template defines the `promise_type` by looking for a nested `promise_type` typedef defined on the return-type. ie. Something like this (but with some extra SFINAE magic so that `promise_type` is not defined if `RET::promise_type` is not defined).

> 默认的 `coroutine_traits` 模板定义 `promise_type` 的方法是查找在返回类型上定义的嵌套 `promise_type` 类型定义，即类似这样（但使用了一些额外的 SFINAE 魔法，因此如果未定义 `RET::promise_type` 则不会定义 `promise_type`）。

```
namespace std::experimental
{
  template<typename RET, typename... ARGS>
  struct coroutine_traits<RET, ARGS...>
  {
    using promise_type = typename RET::promise_type;
  };
}
```

So for coroutine return-types that you have control over, you can just define a nested `promise_type` in your class to have the compiler use that type as the type of the promise object for coroutines that return your class.

> 因此，对于您可以控制的协程返回类型，您只需在类中定义一个嵌套的 `promise_type` 类型，就可以让编译器使用该类型作为返回您类的协程的 promise 对象的类型。

For example:

```
template<typename T>
struct task
{
  using promise_type = task_promise<T>;
  ...
};
```

However, for coroutine return-types that you don’t have control over you can specialise the `coroutine_traits` to define the promise type to use without needing to modify the type.

For example, to define the promise-type to use for a coroutine that returns `std::optional<T>`:

> 不过，对于您无法控制的协程返回类型，您可以对 `coroutine_traits` 进行特殊化，以定义要使用的 promise 类型，而无需修改类型。
>
> 例如，定义用于返回 `std::optional<T>` 的协程的 promise 类型：

```
namespace std::experimental
{
  template<typename T, typename... ARGS>
  struct coroutine_traits<std::optional<T>, ARGS...>
  {
    using promise_type = optional_promise<T>;
  };
}
```

### Identifying a specific coroutine activation frame

When you call a coroutine function, a coroutine frame is created. In order to resume the associated coroutine or destroy the coroutine frame you need some way to identify or refer to that particular coroutine frame.

The mechanism the Coroutines TS provides for this is the `coroutine_handle` type.

The (abbreviated) interface of this type is as follows:

> 调用协程函数时，会创建一个协程帧。为了恢复相关协程或销毁协程帧，您需要某种方法来识别或引用该特定协程帧。
>
> 为此，协程 TS 提供的机制是 `coroutine_handle` 类型。
>
> 该类型的（缩写）接口如下：

```C++
namespace std::experimental
{
  template<typename Promise = void>
  struct coroutine_handle;

  // Type-erased coroutine handle. Can refer to any kind of coroutine.
  // Doesn't allow access to the promise object.
  template<>
  struct coroutine_handle<void>
  {
    // Constructs to the null handle.
    constexpr coroutine_handle();

    // Convert to/from a void* for passing into C-style interop functions.
    constexpr void* address() const noexcept;
    static constexpr coroutine_handle from_address(void* addr);

    // Query if the handle is non-null.
    constexpr explicit operator bool() const noexcept;

    // Query if the coroutine is suspended at the final_suspend point.
    // Undefined behaviour if coroutine is not currently suspended.
    bool done() const;

    // Resume/Destroy the suspended coroutine
    void resume();
    void destroy();
  };

  // Coroutine handle for coroutines with a known promise type.
  // Template argument must exactly match coroutine's promise type.
  template<typename Promise>
  struct coroutine_handle : coroutine_handle<>
  {
    using coroutine_handle<>::coroutine_handle;

    static constexpr coroutine_handle from_address(void* addr);

    // Access to the coroutine's promise object.
    Promise& promise() const;

    // You can reconstruct the coroutine handle from the promise object.
    static coroutine_handle from_promise(Promise& promise);
  };
}
```

You can obtain a `coroutine_handle` for a coroutine in two ways:

1. It is passed to the `await_suspend()` method during a `co_await` expression.
2. If you have a reference to the coroutine’s promise object, you can reconstruct its `coroutine_handle` using `coroutine_handle<Promise>::from_promise()`.

> 您可以通过两种方式获得一个协程的 `coroutine_handle` ：
>
> 1. 在 `co_await` 表达式中将其传递给 `await_suspend()` 方法。
> 2. 如果有协程的 promise 对象的引用，则可以使用 `coroutine_handle<Promise>::from_promise()` 重构其 `coroutine_handle`。

The `coroutine_handle` of the awaiting coroutine will be passed into the `await_suspend()` method of the awaiter after the coroutine has suspended at the `<suspend-point>` of a `co_await` expression. You can think of this `coroutine_handle` as representing the continuation of the coroutine in a [continuation-passing style](https://en.wikipedia.org/wiki/Continuation-passing_style) call.

Note that the `coroutine_handle` is **NOT** and RAII object. You must manually call `.destroy()` to destroy the coroutine frame and free its resources. Think of it as the equivalent of a `void*` used to manage memory. This is for performance reasons: making it an RAII object would add additional overhead to coroutine, such as the need for reference counting.

> 当协程在 "co_await "表达式的`<suspend-point>`处暂停后，等待协程的 "coroutine_handle "将被传入等待者的 "await_suspend() "方法。你可以把这个 `coroutine_handle` 视为在[continuation-passing style](https://en.wikipedia.org/wiki/Continuation-passing_style)调用中代表协程的继续。
>
> 请注意，"coroutine_handle "**不是** RAII 对象。您必须手动调用 `.destroy()` 来销毁协程帧并释放其资源。可以把它想象成一个用来管理内存的`void*`。这是出于性能方面的考虑：将其作为 RAII 对象会给协程增加额外的开销，例如需要进行引用计数。

You should generally try to use higher-level types that provide the RAII semantics for coroutines, such as those provided by [cppcoro](https://github.com/lewissbaker/cppcoro) (shameless plug), or write your own higher-level types that encapsulate the lifetime of the coroutine frame for your coroutine type.

> 一般来说，你应该尽量使用为协程提供 RAII 语义的高层类型，例如 [cppcoro](https://github.com/lewissbaker/cppcoro) 提供的类型（无耻的插播），或者编写自己的高层类型，为你的协程类型封装协程帧的生命周期。

### Customising the behaviour of `co_await`

The promise type can optionally customise the behaviour of every `co_await` expression that appears in the body of the coroutine.

By simply defining a method named `await_transform()` on the promise type, the compiler will then transform every `co_await <expr>` appearing in the body of the coroutine into `co_await promise.await_transform(<expr>)`.

> promise 类型可以选择自定义出现在协程主体中的每个 `co_await` 表达式的行为。
>
> 只需在 promise 类型上定义一个名为 `await_transform()` 的方法，编译器就会将出现在协程主体中的每个 `co_await <expr>` 表达式转换为 `co_await promise.await_transform(<expr>)`。

This has a number of important and powerful uses:

> 这有一些重要而强大的用处：

**It lets you enable awaiting types that would not normally be awaitable.**

> **它让我们能等待一些常规来说不能等待的类型。**

For example, a promise type for coroutines with a `std::optional<T>` return-type might provide an `await_transform()` overload that takes a `std::optional<U>` and that returns an awaitable type that either returns a value of type `U` or suspends the coroutine if the awaited value contains `nullopt`.

> 例如，用于具有 `std::optional<T>` 返回类型的协程的 promise 类型可以提供一个 `await_transform()` 重载，该重载接收一个 `std::optional<U>`，并返回一个可等待类型，该类型要么返回一个 `U` 类型的值，要么在等待值包含 `nullopt` 时暂停协程。

```
template<typename T>
class optional_promise
{
  ...

  template<typename U>
  auto await_transform(std::optional<U>& value)
  {
    class awaiter
    {
      std::optional<U>& value;
    public:
      explicit awaiter(std::optional<U>& x) noexcept : value(x) {}
      bool await_ready() noexcept { return value.has_value(); }
      void await_suspend(std::experimental::coroutine_handle<>) noexcept {}
      U& await_resume() noexcept { return *value; }
    };
    return awaiter{ value };
  }
};
```

**It lets you disallow awaiting on certain types by declaring `await_transform` overloads as deleted.**

> **它可以让我们通过声明`await_transform`的重载来阻止在一个给定的类型上等待，例如删除重载。**

For example, a promise type for `std::generator<T>` return-type might declare a deleted `await_transform()` template member function that accepts any type. This basically disables use of `co_await` within the coroutine.

> 例如，`std::generator<T>` 返回类型的 promise 类型可以声明一个删除的 `await_transform()` 模板成员函数，该函数可以接受任何类型。这基本上禁止了在协程中使用 `co_await`。

```
template<typename T>
class generator_promise
{
  ...

  // Disable any use of co_await within this type of coroutine.
  template<typename U>
  std::experimental::suspend_never await_transform(U&&) = delete;

};
```

**It lets you adapt and change the behaviour of normally awaitable values**

> **它可以让你调整和改变通常可等待值的行为**

For example, you could define a type of coroutine that ensured that the coroutine always resumed from every `co_await` expression on an associated executor by wrapping the awaitable in a `resume_on()` operator (see `cppcoro::resume_on()`).

> 例如，您可以定义一种协程类型，通过用 `resume_on()` 操作符（请参阅 `cppcoro::resume_on()`）包装可等待表达式，确保协程总是从关联执行器上的每个 `co_await` 表达式恢复。

```
template<typename T, typename Executor>
class executor_task_promise
{
  Executor executor;

public:

  template<typename Awaitable>
  auto await_transform(Awaitable&& awaitable)
  {
    using cppcoro::resume_on;
    return resume_on(this->executor, std::forward<Awaitable>(awaitable));
  }
};
```

As a final word on `await_transform()`, it’s important to note that if the promise type defines _any_ `await_transform()` members then this triggers the compiler to transform _all_ `co_await` expressions to call `promise.await_transform()`. This means that if you want to customise the behaviour of `co_await` for just some types that you also need to provide a fallback overload of `await_transform()` that just forwards through the argument.

> 关于`await_transform()`的最后一点，需要注意的是，如果 promise 类型定义了个`await_transform()`成员，那么编译器就会将所有`co_await`表达式转换为调用`promise.await_transform()`。这意味着，如果你只想为某些类型定制 `co_await` 的行为，你还需要提供一个 `await_transform()` 的回退重载，它只需转发参数。

### Customising the behaviour of `co_yield`

The final thing you can customise through the promise type is the behaviour of the `co_yield` keyword.

> 通过 promise 类型可以自定义的最后一件事是 `co_yield` 关键字的行为。

If the `co_yield` keyword appears in a coroutine then the compiler translates the expression `co_yield <expr>` into the expression `co_await promise.yield_value(<expr>)`. The promise type can therefore customise the behaviour of the `co_yield` keyword by defining one or more `yield_value()` methods on the promise object.

Note that, unlike `await_transform`, there is no default behaviour of `co_yield` if the promise type does not define the `yield_value()` method. So while a promise type needs to explicitly opt-out of allowing `co_await` by declaring a deleted `await_transform()`, a promise type needs to opt-in to supporting `co_yield`.

The typical example of a promise type with a `yield_value()` method is that of a `generator<T>` type:

> 如果 `co_yield` 关键字出现在协程中，那么编译器会将表达式 `co_yield <expr>` 转换为表达式 `co_await promise.yield_value(<expr>)`。因此，promise 类型可以通过在 promise 对象上定义一个或多个 `yield_value()` 方法来自定义 `co_yield` 关键字的行为。
>
> 请注意，与 `await_transform` 不同的是，如果 promise 类型没有定义 `yield_value()` 方法，`co_yield` 就没有默认行为。因此，允诺类型需要通过声明删除的 `await_transform()` 来明确选择不允许 `co_await`，而允诺类型则需要选择支持 `co_yield`。
>
> 具有 `yield_value()` 方法的 promise 类型的典型例子是 `generator<T>` 类型：

```
template<typename T>
class generator_promise
{
  T* valuePtr;
public:
  ...

  std::experimental::suspend_always yield_value(T& value) noexcept
  {
    // Stash the address of the yielded value and then return an awaitable
    // that will cause the coroutine to suspend at the co_yield expression.
    // Execution will then return from the call to coroutine_handle<>::resume()
    // inside either generator<T>::begin() or generator<T>::iterator::operator++().
    valuePtr = std::addressof(value);
    return {};
  }
};
```

# Summary

In this post I’ve covered the individual transformations that the compiler applies to a function when compiling it as a coroutine.

Hopefully this post will help you to understand how you can customise the behaviour of different types of coroutines through defining different your own promise type. There are a lot of moving parts in the coroutine mechanics and so there are lots of different ways that you can customise their behaviour.

However, there is still one more important transformation that the compiler performs which I have not yet covered - the transformation of the coroutine body into a state-machine. However, this post is already too long so I will defer explaining this to the next post. Stay tuned!

> 在这篇文章中，我介绍了编译器在将函数编译为协程时对其进行的各种转换。
>
> 希望这篇文章能帮助你理解如何通过定义不同的许诺类型来定制不同类型协程的行为。协程机制中有很多活动部件，因此有很多不同的方法可以自定义它们的行为。
>
> 不过，编译器还会执行一个我尚未涉及的重要转换--将协程主体转换为状态机。不过，这篇文章已经太长了，所以我将推迟到下一篇文章再解释。敬请期待！
