---
layout: post
title: C++协程：编译器变换（译）
date: 2024-02-03
---

- [Introduction](https://lewissbaker.github.io/2022/08/27/understanding-the-compiler-transform#introduction)

- [Setting the Scene](https://lewissbaker.github.io/2022/08/27/understanding-the-compiler-transform#setting-the-scene)

- [Defining the ](https://lewissbaker.github.io/2022/08/27/understanding-the-compiler-transform#defining-the-task-type)`[task](https://lewissbaker.github.io/2022/08/27/understanding-the-compiler-transform#defining-the-task-type)`[ type](https://lewissbaker.github.io/2022/08/27/understanding-the-compiler-transform#defining-the-task-type)

- [Step 1: Determining the promise type](https://lewissbaker.github.io/2022/08/27/understanding-the-compiler-transform#step-1-determining-the-promise-type)

- [Step 2: Creating the coroutine state](https://lewissbaker.github.io/2022/08/27/understanding-the-compiler-transform#step-2-creating-the-coroutine-state)

- [Step 3: Call ](https://lewissbaker.github.io/2022/08/27/understanding-the-compiler-transform#step-3-call-get_return_object)`[get_return_object()](https://lewissbaker.github.io/2022/08/27/understanding-the-compiler-transform#step-3-call-get_return_object)`

- [Step 4: The initial-suspend point](https://lewissbaker.github.io/2022/08/27/understanding-the-compiler-transform#step-4-the-initial-suspend-point)

- [Step 5: Recording the suspend-point](https://lewissbaker.github.io/2022/08/27/understanding-the-compiler-transform#step-5-recording-the-suspend-point)

- [Step 6: Implementing ](https://lewissbaker.github.io/2022/08/27/understanding-the-compiler-transform#step-6-implementing-coroutine_handleresume-and-coroutine_handledestroy)`[coroutine_handle::resume()](https://lewissbaker.github.io/2022/08/27/understanding-the-compiler-transform#step-6-implementing-coroutine_handleresume-and-coroutine_handledestroy)`[ and ](https://lewissbaker.github.io/2022/08/27/understanding-the-compiler-transform#step-6-implementing-coroutine_handleresume-and-coroutine_handledestroy)`[coroutine_handle::destroy()](https://lewissbaker.github.io/2022/08/27/understanding-the-compiler-transform#step-6-implementing-coroutine_handleresume-and-coroutine_handledestroy)`

- [Step 7: Implementing ](https://lewissbaker.github.io/2022/08/27/understanding-the-compiler-transform#step-7-implementing-coroutine_handlepromisepromise-and-from_promise)`[coroutine_handle::promise()](https://lewissbaker.github.io/2022/08/27/understanding-the-compiler-transform#step-7-implementing-coroutine_handlepromisepromise-and-from_promise)`[ and ](https://lewissbaker.github.io/2022/08/27/understanding-the-compiler-transform#step-7-implementing-coroutine_handlepromisepromise-and-from_promise)`[from_promise()](https://lewissbaker.github.io/2022/08/27/understanding-the-compiler-transform#step-7-implementing-coroutine_handlepromisepromise-and-from_promise)`

- [Step 8: The beginnings of the coroutine body](https://lewissbaker.github.io/2022/08/27/understanding-the-compiler-transform#step-8-the-beginnings-of-the-coroutine-body)

- [Step 9: Lowering the ](https://lewissbaker.github.io/2022/08/27/understanding-the-compiler-transform#step-9-lowering-the-co_await-expression)`[co_await](https://lewissbaker.github.io/2022/08/27/understanding-the-compiler-transform#step-9-lowering-the-co_await-expression)`[ expression](https://lewissbaker.github.io/2022/08/27/understanding-the-compiler-transform#step-9-lowering-the-co_await-expression)

- [Step 10: Implementing ](https://lewissbaker.github.io/2022/08/27/understanding-the-compiler-transform#step-10-implementing-unhandled_exception)`[unhandled_exception()](https://lewissbaker.github.io/2022/08/27/understanding-the-compiler-transform#step-10-implementing-unhandled_exception)`

- [Step 11: Implementing ](https://lewissbaker.github.io/2022/08/27/understanding-the-compiler-transform#step-11-implementing-co_return)`[co_return](https://lewissbaker.github.io/2022/08/27/understanding-the-compiler-transform#step-11-implementing-co_return)`

- [Step 12: Implementing ](https://lewissbaker.github.io/2022/08/27/understanding-the-compiler-transform#step-12-implementing-final_suspend)`[final_suspend()](https://lewissbaker.github.io/2022/08/27/understanding-the-compiler-transform#step-12-implementing-final_suspend)`

- [Step 13: Implementing symmetric-transfer and the noop-coroutine](https://lewissbaker.github.io/2022/08/27/understanding-the-compiler-transform#step-13-implementing-symmetric-transfer-and-the-noop-coroutine)

- [One last thing](https://lewissbaker.github.io/2022/08/27/understanding-the-compiler-transform#one-last-thing)

- [Tying it all together](https://lewissbaker.github.io/2022/08/27/understanding-the-compiler-transform#tying-it-all-together)

# Introduction

Previous blogs in the series on “Understanding C++ Coroutines” talked about the different kinds of transforms the compiler performs on a coroutine and its `co_await`, `co_yield` and `co_return` expressions. These posts described how each expression was lowered by the compiler to calls to various customisation points/methods on user-defined types.

> 本系列之前的博客文章讨论了编译器对协程及其 `co_await`、`co_yield` 和 `co_return` 表达式的不同转换。这些帖子描述了编译器如何将每个表达式转换（原词“lowered”指转换为更低级抽象的实际形式，如汇编代码，但这里指的是非协程形式的指令式代码）为对用户定义类型上的各种定制点/定制方法的调用。

1. [Coroutine Theory](https://lewissbaker.github.io/2017/09/25/coroutine-theory)

2. [C++ Coroutines: Understanding operator co_await](https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await)

3. [C++ Coroutines: Understanding the promise type](https://lewissbaker.github.io/2018/09/05/understanding-the-promise-type)

4. [C++ Coroutines: Understanding Symmetric Transfer](https://lewissbaker.github.io/2020/05/11/understanding_symmetric_transfer)

However, there was one part of these descriptions that may have left you unsatisfied. The all hand-waved over the concept of a “suspend-point” and said something vague like “the coroutine suspends here” and “the coroutine resumes here” but didn’t really go into detail about what that actually means or how it might be implemented by the compiler.

> 然而，这些描述中有一部分可能让你感到不满。它们全都轻描淡写地提到了“挂起点”的概念，并说了一些模糊的话，比如如“在这里挂起协程”和“在这里恢复协程”，但没有真正详细说明这到底意味着什么，或者编译器如何实现它。

In this post I am going to go a bit deeper to show how all the concepts from the previous posts come together. I’ll show what happens when a coroutine reaches a suspend-point by walking through the lowering of a coroutine into equivalent non-coroutine, imperative C++ code.

> 在这篇博文中，我将更深入地展示之前的博文中的所有概念如何融合在一起。我将展示当一个协程达到挂起点时发生了什么，并通过将协程转换为等价的非协程、命令式 C++ 代码来进行演示。

Note that I am not going to describe exactly how a particular compiler lowers coroutines into machine code (compilers have extra tricks up their sleeves here), but rather just one possible lowering of coroutines into portable C++ code.

Warning: This is going to be a fairly deep dive!

> 请注意，我不会描述特定编译器如何将协程转换为机器代码（编译器在这方面有一些额外的技巧），而只是展示协程到可移植 C++ 代码的一种可能转换。
>
> 警告：这将是一个相当深入的探讨！

# Setting the Scene

For starters, let’s assume we have a basic `task` type that acts as both an awaitable and a coroutine return-type. For the sake of simplicity, let’s assume that this coroutine type allows producing a result of type `int` asynchronously.

> 首先，假设我们有一个基本的 "任务 "类型，它既是可等待类型，又是协程返回类型。为了简单起见，我们假设这个协程类型允许异步产生一个 `int` 类型的结果。

In this post we are going to walk through how to lower the following coroutine function into C++ code that does not contain any of the coroutine keywords `co_await`, `co_return` so that we can better understand what this means.

> 在这篇文章中，我们将介绍如何将下面的协程函数转换为不包含任何协程关键字 `co_await`、`co_return` 的 C++ 代码，以便更好地理解这意味着什么。

```C++
// Forward declaration of some other function. Its implementation is not relevant.
task f(int x);

// A simple coroutine that we are going to translate to non-C++ code
task g(int x) {
    int fx = co_await f(x);
    co_return fx * fx;
}
```

# Defining the `task` type

To begin, let us first declare the `task` class that we will be working with.

> 首先，让我们声明将要使用的`task`类。

For the purposes of understanding how the coroutine is lowered, we do not need to know the definitions of the methods for this type. The lowering will just be inserting calls to them.

> 为了理解如何转换协程，我们不需要知道该类型的方法定义。转换只是插入对它们的调用。

The definitions of these methods are not complicated, and I will leave them as an exercise for the reader as practice for understanding the previous posts.

> 这些方法的定义并不复杂，我将把它们留作练习，以便读者理解前面的文章。

```C++
class task {
public:
    struct awaiter;

    class promise_type {
    public:
        promise_type() noexcept;
        ~promise_type();

        struct final_awaiter {
            bool await_ready() noexcept;
            std::coroutine_handle<> await_suspend(std::coroutine_handle<promise_type> h) noexcept;
            void await_resume() noexcept;
        };

        task get_return_object() noexcept;
        std::suspend_always initial_suspend() noexcept;
        final_awaiter final_suspend() noexcept;
        void unhandled_exception() noexcept;
        void return_value(int result) noexcept;

    private:
        friend task::awaiter;
        std::coroutine_handle<> continuation_;
        std::variant<std::monostate, int, std::exception_ptr> result_;
    };

    task(task&& t) noexcept;
    ~task();
    task& operator=(task&& t) noexcept;

    struct awaiter {
        explicit awaiter(std::coroutine_handle<promise_type> h) noexcept;
        bool await_ready() noexcept;
        std::coroutine_handle<promise_type> await_suspend(
            std::coroutine_handle<> h) noexcept;
        int await_resume();
    private:
        std::coroutine_handle<promise_type> coro_;
    };

    awaiter operator co_await() && noexcept;

private:
    explicit task(std::coroutine_handle<promise_type> h) noexcept;

    std::coroutine_handle<promise_type> coro_;
};
```

The structure of this task type should be familiar to those that have read the [C++ Coroutines: Understanding Symmetric Transfer](https://lewissbaker.github.io/2020/05/11/understanding_symmetric_transfer) post.

> 这个task类型的结构和我们在之前理解对称转移一文中读到的相似

# Step 1: Determining the promise type

```C++
task g(int x) {
    int fx = co_await f(x);
    co_return fx * fx;
}
```

When the compiler sees that this function contains one of the three coroutine keywords (`co_await`, `co_yield` or `co_return`) it starts the coroutine transformation process.

The first step here is determining the `promise_type` to use for this coroutine.

This is determined by substituting the return-type and argument-types of the signature as template arguments to the `std::coroutine_traits` type.

e.g. For our function, `g`, which has return type `task` and a single argument of type `int`, the compiler will look this up using `std::coroutine_traits<task, int>::promise_type`.

Let’s define an alias so we can refer to this type later:

> 当编译器发现该函数包含三个协程关键字之一（`co_await`, `co_yield` 或`co_return`）时，就会开始协程转换过程。
>
> 第一步是确定该协程要使用的 `promise_type`。
>
> 这是通过将方法签名的返回类型和参数类型代入为 `std::coroutine_traits` 类型的类型参数来确定的。
>
> 例如，对于我们的函数 `g`，它的返回类型是 `task`，单个参数的类型是 `int`，编译器将使用 `std::coroutine_traits<task, int>::promise_type` 来查找。
>
> 让我们定义一个别名，以便以后可以引用这个类型：

```C++
using __g_promise_t = std::coroutine_traits<task, int>::promise_type;
```

**Note: I am using leading double-underscore here to indicate symbols internal to the** **compiler that the compiler generates. Such symbols are reserved by the implementation** **and should *not* be used in your own code.**

Now, as we have not specialised `std::coroutine_traits` this will instantiate the primary template which just defines the nested `promise_type` as an alias of the nested `promise_type` name of the return-type. i.e. this should resolve to the type `task::promise_type` in our case.

> **注意：我在这里使用前导双下划线来表示编译器生成的编译器内部符号。这些符号由实现保留，不应在你自己的代码中使用。**
>
> 现在，由于我们没有对 `std::coroutine_traits` 进行特殊化，这将实例化主模板，该模板只是将嵌套的 `promise_type` 定义为返回类型的嵌套 `promise_type` 名称的别名。

# Step 2: Creating the coroutine state

A coroutine function needs to preserve the state of the coroutine, parameters and local variables when it suspends so that they remain available when the coroutine is later resumed.

This state, in C++ standardese, is called the *coroutine state* and is typically heap allocated.

Let’s start by defining a struct for the coroutine-state for the coroutine, `g`.

We don’t know what the contents of this type are going to be yet, so let’s just  leave it empty for now.

> 协程函数在暂停时需要保留协程的状态、参数和局部变量，以便在以后恢复协程时它们仍然可用。
>
> 这种状态在 C++ 标准语言中称为*协程状态*，通常是堆分配的。
>
> 让我们先为协程的协程状态定义一个结构体`g`。
>
> 我们还不知道这个结构体的内容是什么，所以暂时让它为空。

```C++
struct __g_state {
  // to be filled out
};
```

The coroutine state contains a number of different things:

- The promise object

- Copies of any function parameters

- Information about the suspend-point that the coroutine is currently suspended at and how to resume/destroy it

- Storage for any local variables / temporaries whose lifetimes span a suspend-point

Let’s start by adding storage for the promise object and parameter copies.

> 协程状态包含许多不同的东西：
>
> - 承诺(promise)对象
>
> - 所有函数参数的副本
>
> - 协程当前暂停的暂停点信息，以及如何恢复/销毁暂停点的信息
>
> - 生命周期跨越暂停点的任何局部变量/临时变量的存储空间
>
> 我们先来添加 promise 对象和参数副本的存储空间。

```C++
struct __g_state {
    int x;
    __g_promise_t __promise;

    // to be filled out
};
```

Next we should add a constructor to initialise these data-members.

Recall that the compiler will first attempt to call the promise constructor with lvalue-references to the parameter copies, if that call is valid, otherwise fall back to calling the default constructor of the promise type.

Let’s create a simple helper to assist with this:

> 接下来，我们应该添加一个构造函数来初始化这些数据成员。
>
> 回想一下，如果调用有效，编译器会首先尝试调用带有参数副本 lvalue 引用的 promise 构造函数，否则会返回调用 promise 类型的默认构造函数。
>
> 让我们创建一个简单的辅助函数来帮助解决这个问题：

```C++
template<typename Promise, typename... Params>
Promise construct_promise([[maybe_unused]] Params&... params) {
    if constexpr (std::constructible_from<Promise, Params&...>) {
        return Promise(params...);
    } else {
        return Promise();
    }
}
```

Thus the coroutine-state constructor might look something like this:

> 合适的协程状态类构造函数可能是这样的：

```C++
struct __g_state {
    __g_state(int&& x)
    : x(static_cast<int&&>(x))
    , __promise(construct_promise<__g_promise_t>(x))
    {}

    int x;
    __g_promise_t __promise;
    // to be filled out
};
```

Now that we have the beginnings of a type to represent the coroutine-state, let’s also start to stub out the beginnings of the lowered implementation of `g()` by having it heap-allocate an instance of the `__g_state` type, passing the function parameters so they can be copied/ moved into the coroutine-state.

> 既然我们已经有了表示协程状态的类型的雏形，那么我们也可以让它堆分配一个 `__g_state` 类型的实例，传递函数参数，以便将它们复制/移动到协程状态中，从而开始构建 `g()` 的低级实现。

Some terminology - I use the term “ramp function” to refer to the part of the coroutine implementation containing the logic that initialises the coroutine state and gets it ready to start executing the coroutine. i.e. it is like an on-ramp for entering execution of the coroutine body.

> 一些术语--我使用 "过渡函数"一词来指协程实现的一部分，其中包含初始化协程状态并准备开始执行协程的逻辑。

```C++
task g(int x) {
    auto* state = new __g_state(static_cast<int&&>(x));
    // ... implement rest of the ramp function
}
```

Note that our promise-type does not define its own custom `operator new` overloads, and so we are just calling global `::operator new` here.

> 请注意，我们的 promise 类型没有定义自己的自定义 `operator new` 重载，因此我们只是在这里调用全局 `::operator new`。

If the promise type *did* define a custom `operator new` then we’d call that instead of the global `::operator new`. We would first check whether `operator new` was callable with the argument list `(size, paramLvalues...)` and if so call it with that argument list. Otherwise, we’d call it with just the `(size)` argument list. The ability for the `operator new` to get access to the parameter list of the coroutine function is sometimes called “parameter preview” and is useful in cases where you want to use an allocator passed as a parameter to allocate storage for the coroutine-state.

If the compiler found any definition of `__g_promise_t::operator new` then we’d lower to the following logic instead:

> 如果 promise 类型*确实*定义了自定义的 `operator new` ，那么我们就会调用它，而不是全局的 `::operator new`。我们首先会检查 `operator new` 是否可以用参数列表 `(size, paramLvalues...)` 调用，如果可以，就用该参数列表调用。否则，我们将仅使用参数列表 `(size)` 来调用它。让 `operator new` 获取协程函数参数列表的能力有时被称为 "参数预览"，在想要使用作为参数传递的分配器为协程状态分配存储空间的情况下非常有用。
>
> 如果编译器找到了 `__g_promise_t::operator new` 的任何定义，那么我们就会采用下面的逻辑：

```C++
template<typename Promise, typename... Args>
void* __promise_allocate(std::size_t size, [[maybe_unused]] Args&... args) {
  if constexpr (requires { Promise::operator new(size, args...); }) {
    return Promise::operator new(size, args...);
  } else {
    return Promise::operator new(size);
  }
}

task g(int x) {
    void* state_mem = __promise_allocate<__g_promise_t>(sizeof(__g_state), x);
    __g_state* state;
    try {
        state = ::new (state_mem) __g_state(static_cast<int&&>(x));
    } catch (...) {
        __g_promise_t::operator delete(state_mem);
        throw;
    }
    // ... implement rest of the ramp function
}
```

Also, this promise-type does not define the `get_return_object_on_allocation_failure()` static member function. If this function is defined on the promise-type then the allocation here would instead use the `std::nothrow_t` form of `operator new` and upon returning `nullptr` would then `return __g_promise_t::get_return_object_on_allocation_failure();`.

i.e. it would look something like this instead:

> 此外，此Promise类型没有定义 `get_return_object_on_allocation_failure()` 静态成员函数。如果在 promise-type 上定义了该函数，那么这里的分配将使用 `std::nothrow_t` 形式的 `operator new` 并在返回 `nullptr` 时 `return __g_promise_t::get_return_object_on_allocation_failure();` 
>
> 也就是说，它看起来会像下面这样

```C++
task g(int x) {
    auto* state = ::new (std::nothrow) __g_state(static_cast<int&&>(x));
    if (state == nullptr) {
        return __g_promise_t::get_return_object_on_allocation_failure();
    }
    // ... implement rest of the ramp function
}
```

For simplicity for the rest of the example, we’ll just use the simplest form that calls the global `::operator new` memory allocation function.

> 为了简化示例的其余部分，我们将只使用调用全局 ::operator new 内存分配函数的最简单形式。

# Step 3: Call `get_return_object()`

The next thing the ramp function does is to call the `get_return_object()` method on the promise object to obtain the return-value of the ramp function.

> 接下来，过渡函数会调用 promise 对象上的`get_return_object()`方法，以获取过渡函数的返回值。

The return value is stored as a local variable and is returned at the end of the ramp function (after the other steps have been completed).

> 返回值存储为一个局部变量，并在过渡函数结束时（其他步骤完成后）返回。

```C++
task g(int x) {
    auto* state = new __g_state(static_cast<int&&>(x));
    decltype(auto) return_value = state->__promise.get_return_object();
    // ... implement rest of ramp function
    return return_value;
}
```

However, now it’s possible that the call to `get_return_object()` might throw, and in which case we want to free the allocated coroutine state. So for good measure, let’s give ownership of the state to a `std::unique_ptr` so that it’s freed in case a subsequent operation throws an exception:

> 不过，现在调用 `get_return_object()`可能会抛出异常，在这种情况下，我们需要释放已分配的协程状态。因此，为了稳妥起见，我们将状态的所有权赋予一个`std::unique_ptr`，以便在后续操作抛出异常时释放它：

```C++
task g(int x) {
    std::unique_ptr<__g_state> state(new __g_state(static_cast<int&&>(x)));
    decltype(auto) return_value = state->__promise.get_return_object();
    // ... implement rest of ramp function
    return return_value;
}
```

# Step 4: The initial-suspend point

The next thing the ramp function does after calling `get_return_object()` is to start executing the body of the coroutine, and the first thing to execute in the body of the coroutine is the initial suspend-point. i.e. we evaluate `co_await promise.initial_suspend()`.

> 调用 get_return_object()后，斜坡函数接下来要做的事情就是开始执行协程的主体，而协程主体中首先要执行的就是初始暂停点，即对 `co_await promise.initial_suspend()`求值。

Now, ideally we’d just treat the coroutine as initially suspended and then just implement the launching of the coroutine as a resumption of the initially suspended coroutine. However, the specification of the initial-suspend point has a few quirks with regards to how it handles exceptions and the lifetime of the coroutine state. This was a late tweak to the semantics of the initial-suspend point just before C++20 was released to fix some perceived issues here.

> 理想情况下，我们只需将协程视为初始暂停，然后将启动协程作为恢复初始暂停的协程来实现即可。然而，初始暂停点的规范在如何处理异常和协程状态的生命周期方面有一些怪癖。这是在 C++20 发布之前对初始暂停点的语义进行的后期调整，以解决这里的一些已知问题。

Within the evaluation of the initial-suspend-point, if an exception is thrown either from:

> 在初始暂停点的求值过程中，如果以下任一抛出异常：

- the call to `initial_suspend()`,

- the call to `operator co_await()` on the returned awaitable (if one is defined),

- the call to `await_ready()` on the awaiter, or

- the call to `await_suspend()` on the awaiter

Then the exception propagates back to the caller of the ramp function and the coroutine state is automatically destroyed.

> 异常会传播回过渡函数的调用者，并且这个协程的状态会自动销毁。

If an exception is thrown either from:

> 如果异常从下面这些地方抛出来：

- the call to `await_resume()`,

- the destructor of the object returned from `operator co_await()` (if applicable), or

- the destructor of the object returned from `initial_suspend()`

Then this exception is caught by the coroutine body and `promise.unhandled_exception()` is called.

> 这些异常会通过协程体捕获，之后`promise.unhandled_exception()`就会被调用

This means we need to be a bit careful how we handle transforming this part, as some parts will need to live in the ramp function and other parts in the coroutine body.

> 这告诉我们，对于将这部分转换为存在于过渡函数和协程体中的多个部分的处理一定要小心

Also, since the objects returned from `initial_suspend()` and (optionally) `operator co_await()` will have lifetimes that span a suspend-point (they are created before the point at which the coroutine suspends and are destroyed after it resumes) the storage for those objects will need to be placed in the coroutine state.

> 当然，由于`initial_suspend()`和`operator co_await()`返回的对象的生命周期会跨过一个暂停点（它们的创建早于协程中的暂停点并且在协程恢复之后销毁），这些对象的要被存储到协程的状态中。

In our particular case, the type returned from `initial_suspend()` is `std::suspend_always`, which happens to be an empty, trivially constructible type. However, logically we still need to store an instance of this type in the coroutine state, so we’ll add storage for it anyway just to show how this works.

> 在我们的例子中，`initial_suspend()`返回的类型是`std::suspend_always`，这个类型碰巧是个空的、平凡构造的类型。但是，逻辑上我们仍然需要在协程状态中保存该类型的一个实例，所以我们还是要为它添加存储空间，以展示它是如何工作的。

This object will only be constructed at the point that we call `initial_suspend()`, so we need to add a data-member of a certain type that that allows us to explicitly control its lifetime.

> 这个对象只有在我们调用 `initial_suspend()` 时才会被构造，因此我们需要添加一个特定类型的数据成员，以便显式地控制其生命周期。

To support this, let’s first define a helper class, `manual_lifetime` that is trivally constructible and trivially destructible but that lets us explicitly construct/destruct the value stored there when we need to.

> 为了支持这一点，让我们首先定义一个辅助类 `manual_lifetime`，它是可构造和可销毁的，但可以让我们在需要时显式地构造/销毁存储在其中的值。

```C++
template<typename T>
struct manual_lifetime {
    manual_lifetime() noexcept = default;
    ~manual_lifetime() = default;

    // Not copyable/movable
    manual_lifetime(const manual_lifetime&) = delete;
    manual_lifetime(manual_lifetime&&) = delete;
    manual_lifetime& operator=(const manual_lifetime&) = delete;
    manual_lifetime& operator=(manual_lifetime&&) = delete;

    template<typename Factory>
        requires
            std::invocable<Factory&> &&
            std::same_as<std::invoke_result_t<Factory&>, T>
    T& construct_from(Factory factory) noexcept(std::is_nothrow_invocable_v<Factory&>) {
        return *::new (static_cast<void*>(&storage)) T(factory());
    }

    void destroy() noexcept(std::is_nothrow_destructible_v<T>) {
        std::destroy_at(std::launder(reinterpret_cast<T*>(&storage)));
    }

    T& get() & noexcept {
        return *std::launder(reinterpret_cast<T*>(&storage));
    }

private:
    alignas(T) std::byte storage[sizeof(T)];
};
```

Note that the `construct_from()` method is designed to take a lambda here rather than taking the constructor arguments. This allows us to make use of the guaranteed copy-elision when initialising a variable with the result of a function-call to construct the object in-place. If it were instead to take the constructor arguments then we’d end up calling an extra move-constructor unnecessarily.

> 需要注意的是，`construct_from()` 方法的设计目的是在这里使用 lambda 而不是使用构造函数参数。这使得我们在使用函数调用的结果初始化变量时，可以利用确定的复制消除来就地构建对象。如果使用构造函数参数，我们就会不必要地调用额外的移动构造函数。

Now we can declare a data-member for the temporary returned by `promise.initial_suspend()` using this `manual_lifetime` structure.

> 现在，我们可以用这个 `manual_lifetime` 结构为 `promise.initial_suspend()` 返回的临时对象声明一个数据成员。

```C++
struct __g_state {
    __g_state(int&& x);

    int x;
    __g_promise_t __promise;
    manual_lifetime<std::suspend_always> __tmp1;
    // to be filled out
};
```

The `std::suspend_always` type does not have an `operator co_await()` so we do not need to reserve storage for an extra temporary for the result of that call here.

Once we’ve constructed this object by calling `intial_suspend()`, we then need to call the trio of methods to implement the `co_await` expression: `await_ready()`, `await_suspend()` and `await_resume()`.

When invoking `await_suspend()` we need to pass it a handle to the current coroutine. For now we can just call `std::coroutine_handle<__g_promise_t>::from_promise()` and pass a reference to that promise. We’ll look at the internals of what this does a little later.

> `std::suspend_always `类型没有 `operator co_await()`，因此我们不需要为调用结果预留额外的临时存储空间。
>
> 调用 `intial_suspend()` 构造了这个对象后，我们需要调用三个方法来实现 `coo_await` 表达式：`await_ready()`、`await_suspend()` 和`await_resume()`。
>
> 调用 `await_suspend()` 时，我们需要向它传递一个当前 coroutine 的句柄。现在，我们只需调用 `std::coroutine_handle<__g_promise_t>::from_promise()` 并传递该 promise 的引用即可。我们稍后再看看它的内部结构。

Also, the result of the call to `.await_suspend(handle)` has type `void` and so we do not need to consider whether to resume this coroutine or another coroutine after calling `await_suspend()` like we do for the `bool` and `coroutine_handle`-returning flavours.

Finally, as all of the method invocations on the `std::suspend_always` awaiter are declared `noexcept`, we don’t need to worry about exceptions. If they were potentially throwing then we’d need to add extra code to make sure that the temporary `std::suspend_always` object was destroyed before the exception propagated out of the ramp function.

Once we get to the point where `await_suspend()` has returned successfully or where we are about to start executing the coroutine body we enter the phase where we no longer need to automatically destroy the coroutine-state if an exception is thrown. So we can call `release()` on the `std::unique_ptr` owning the coroutine state to prevent it from being destroyed when we return from the function.

So now we can implement the first part of the initial-suspend expression as follows:

> 此外，调用 `.await_suspend(handle)` 的结果类型为 `void`，因此在调用 `await_suspend()` 后，我们不需要考虑是恢复这个协程还是另一个协程，就像我们在调用 `bool` 和 `coroutine_handle` 返回的协程时所做的那样。
>
> 最后，由于 `std::suspend_always` 等待器上的所有方法调用都声明为 `noexcept`，所以我们不需要担心异常。如果它们有可能抛出异常，那么我们就需要添加额外的代码，以确保在异常传播出过渡函数之前，临时的 `std::suspend_always` 对象已被销毁。
>
> 一旦`await_suspend()`成功返回，或者我们即将开始执行协程主体，我们就进入了不再需要在异常抛出时自动销毁协程状态的阶段。因此，我们可以在拥有协程状态的 `std::unique_ptr` 上调用 `release()` 来防止它在函数返回时被销毁。
>
> 因此，现在我们可以如下实现初始-暂停表达式的第一部分：

```C++
task g(int x) {
    std::unique_ptr<__g_state> state(new __g_state(static_cast<int&&>(x)));
    decltype(auto) return_value = state->__promise.get_return_object();

    state->__tmp1.construct_from([&]() -> decltype(auto) {
        return state->__promise.initial_suspend();
    });
    if (!state->__tmp1.get().await_ready()) {
        //
        // ... suspend-coroutine here
        //
        state->__tmp1.get().await_suspend(
            std::coroutine_handle<__g_promise_t>::from_promise(state->__promise));

        state.release();

        // fall through to return statement below.
    } else {
        // Coroutine did not suspend.

        state.release();

        //
        // ... start executing the coroutine body
        //
    }
    return __return_val;
}
```

The call to `await_resume()` and the destructor of `__tmp1` will appear in the coroutine body and so they do not appear in the ramp function.

We now have a (mostly) functional evaluation of the initial-suspend point, but we still have a couple of TODO’s in the code for this ramp function. To be able to resolve these we will first need to take a detour to look at the strategy for suspending a coroutine and later resuming it.

> 对 `await_resume()` 的调用和 `__tmp1` 的析构函数将出现在协程主体中，因此它们不会出现在过渡函数中。
>
> 现在，我们已经对初始暂停点进行了（大部分）功能评估，但在这个过渡函数的代码中，我们仍有几个 TODO。为了能够解决这些问题，我们首先需要绕道来看看暂停协程并随后恢复的策略。

# Step 5: Recording the suspend-point

When a coroutine suspends, it needs to make sure it resumes at the same point in the control flow that it suspended at.

It also needs to keep track of which objects with automatic-storage duration are alive at each suspend-point so that it knows what needs to be destroyed if the coroutine is destroyed instead of being resumed.

One way to implement this is to assign each suspend-point in the coroutine a unique number and then store this in an integer data-member of the coroutine state.

>当协程暂停时，它需要确保在控制流中与暂停点相同的位置恢复。
>
>它还需要跟踪在每个暂停点哪些具有自动生命周期的对象还存活着，以便在协程被销毁（而不是恢复）时知道哪些对象需要销毁。
>
>实现这一点的一种方法是为协程中的每个暂停点分配一个唯一的编号，然后将其存储在协程状态的一个整数数据成员中。

Then whenever a coroutine suspends, it writes the number of the suspend-point at which it is suspending to the coroutine state, and when it is resumed/destroyed we then inspect this integer to see which suspend point it was suspended at.

Note that this is not the only way of storing the suspend-point in the coroutine state, however all 3 major compilers (MSVC, Clang, GCC) use this approach as the time this post was authored (c. 2022). Another potential solution is to use separate resume/destroy function-pointers for each suspend-point, although we will not be exploring this strategy in this post.

So let’s extend our coroutine-state with an integer data-member to store the suspend-point index and initialise it to zero (we’ll always use this as the value for the initial-suspend point).

> 然后，每当协程暂停时，它就会将暂停时的暂停点编号写入协程状态，当它被恢复/销毁时，我们就会检查这个整数，查看它是在哪个暂停点暂停的。
>
> 请注意，这并不是在协程状态中存储暂停点的唯一方法，不过在撰写这篇文章时（约 2022 年），所有 3 个主要编译器（MSVC、Clang、GCC）都使用了这种方法。另一种可能的解决方案是为每个暂停点使用单独的恢复/销毁函数指针，不过我们不会在这篇文章中探讨这种策略。
>
> 因此，让我们用一个整数数据成员来扩展协程状态，以存储暂停点索引，并将其初始化为零（我们将始终使用它作为初始暂停点的值）。

```C++
struct __g_state {
    __g_state(int&& x);

    int x;
    __g_promise_t __promise;
    int __suspend_point = 0;  // <-- add the suspend-point index
    manual_lifetime<std::suspend_always> __tmp1;
    // to be filled out
};
```

# Step 6: Implementing `coroutine_handle::resume()` and `coroutine_handle::destroy()`

When a coroutine is resumed by calling `coroutine_handle::resume()` we need this to end up invoking some function that implements the rest of the body of the suspended coroutine. The invoked body function can then look up the suspend-point index and jump to the appropriate point in the control-flow.

We also need to implement the `coroutine_handle::destroy()` function so that it invokes the appropriate logic to destroy any in-scope objects at the current suspend-point and we need to implement `coroutine_handle::done()` to query whether the current suspend-point is a final-suspend-point.

> 当通过调用`coroutine_handle::resume()`来恢复协程时，我们需要最终调用某个函数来实现暂停的协程的其余部分。被调用的主体函数可以查找暂停点索引，然后跳转到控制流中的适当位置。
>
> 我们还需要实现 `coroutine_handle::destroy()`函数，以便调用适当的逻辑来销毁当前暂停点上的任何范围内对象，我们还需要实现`coroutine_handle::done()`，以查询当前暂停点是否为最终暂停点。

The interface of the `coroutine_handle` methods does not know about the concrete coroutine state type - the `coroutine_handle<void>` type can point to *any* coroutine instance. This means we need to implement them in a way that type-erases the coroutine state type.

We can do this by storing function-pointers to the resume/destroy functions for that coroutine type and having `coroutine_handle::resume/destroy()` invoke those function-pointers.

The `coroutine_handle` type also needs to be able to be converted to/from a `void*` using the `coroutine_handle::address()` and `coroutine_handle::from_address()` methods.

Furthermore, the coroutine can be resumed/destroyed from *any* handle to that coroutine - not just the handle that was passed to the most recent `await_suspend()` call.

> `coroutine_handle`方法的接口并不知道具体的协程状态类型，`coroutine_handle<void>`类型可以指向*任何*个协程实例。这意味着我们需要以类型化协程状态类型的方式来实现它们。
>
> 为此，我们可以存储指向该协程类型的恢复/销毁函数的函数指针，并让 `coroutine_handle::resume/destroy()` 调用这些函数指针。
>
> 还需要使用 `coroutine_handle::address()` 和 `coroutine_handle::from_address()` 方法在 `coroutine_handle` 和`void*` 类型之间相互转换。
>
> 此外，协程可以从该协程的 *any* 句柄恢复/销毁，而不仅仅是最近一次调用 `await_suspend()` 时传递的句柄。

These requirements lead us to define the `coroutine_handle` type so that it only contains a pointer to the coroutine-state and that we store the resume/destroy function pointers as data-members of the coroutine state, rather than, say, storing the resume/destroy function pointers in the `coroutine_handle`.

Also, since we need the `coroutine_handle` to be able to point to an arbitrary coroutine-state object we need the layout of the function-pointer data-members to be consistent across all coroutine-state types.

One straight forward way of doing this is having each coroutine-state type inherit from some base-class that contains these data-members.

e.g. We can define the following type as the base-class for all coroutine-state types

> 这些要求导致我们在定义`coroutine_handle`类型时，使其只包含指向协程状态的指针，并将恢复/销毁函数指针作为协程状态的数据成员存储，而不是将恢复/销毁函数指针存储在`coroutine_handle`中。
>
> 此外，由于我们需要`coroutine_handle`能够指向任意的协程状态对象，因此我们需要函数指针数据成员的布局在所有协程状态类型中保持一致。
>
> 要做到这一点，一种简单直接的方法就是让每个协程类型都继承于某个包含这些数据成员的基类。
>
> 例如，我们可以定义以下类型作为所有协程类型的基类

```c++
struct __coroutine_state {
    using __resume_fn = void(__coroutine_state*);
    using __destroy_fn = void(__coroutine_state*);

    __resume_fn* __resume;
    __destroy_fn* __destroy;
};
```

Then the `coroutine_handle::resume()` method can simply call `__resume()`, passing a pointer to the `__coroutine_state` object. Similarly, we can do this for the `coroutine_handle::destroy()` method and the `__destroy` function-pointer.

For the `coroutine_handle::done()` method, we choose to treat a null `__resume` function pointer as an indication that we are at a final-suspend-point. This is convenient since the final suspend point does not support `resume()`, only `destroy()`. If someone tries to call `resume()` on a coroutine suspended at the final-suspend-point (which has undefined-behaviour) then they end up calling a null function pointer which should fail pretty quickly and point out their error.

Given this, we can implement the `coroutine_handle<void>` type as follows:

> 然后，coroutine_handle::resume() 方法可以简单地调用 `__resume() `并传递一个指向 `__coroutine_state `对象的指针。同样，我们也可以这样处理 `coroutine_handle::destroy()` 方法和 `__destroy `函数指针。
>
> 对于`coroutine_handle::done()`方法，我们选择将`__resume` 函数指针为空作为处于最终暂停点的指示。这样做很方便，因为最终暂停点不支持 `resume()`，只支持 `destroy()`。如果有人试图对暂停在 final-suspend-point 的协程调用 `resume()`（该协程有未定义的行为），那么他们最终会调用一个空函数指针，而该函数指针会很快失效并指出他们的错误。
>
> 有鉴于此，我们可以如下实现 `coroutine_handle<void> `类型：

```c++
namespace std
{
    template<typename Promise = void>
    class coroutine_handle;

    template<>
    class coroutine_handle<void> {
    public:
        coroutine_handle() noexcept = default;
        coroutine_handle(const coroutine_handle&) noexcept = default;
        coroutine_handle& operator=(const coroutine_handle&) noexcept = default;

        void* address() const {
            return static_cast<void*>(state_);
        }

        static coroutine_handle from_address(void* ptr) {
            coroutine_handle h;
            h.state_ = static_cast<__coroutine_state*>(ptr);
            return h;
        }

        explicit operator bool() noexcept {
            return state_ != nullptr;
        }
        
        friend bool operator==(coroutine_handle a, coroutine_handle b) noexcept {
            return a.state_ == b.state_;
        }

        void resume() const {
            state_->__resume(state_);
        }
        void destroy() const {
            state_->__destroy(state_);
        }

        bool done() const {
            return state_->__resume == nullptr;
        }

    private:
        __coroutine_state* state_ = nullptr;
    };
}
```

# Step 7: Implementing `coroutine_handle<Promise>::promise()` and `from_promise()`

For the more general `coroutine_handle<Promise>` specialisation, most of the implementations can just reuse the `coroutine_handle<void>` implementations. However, we also need to be able to get access to the promise object of the coroutine-state, returned from the `promise()` method, and also construct a `coroutine_handle` from a reference to the promise-object.

However, again we cannot simply point to the concrete coroutine state type since the `coroutine_handle<Promise>` type must be able to refer to any coroutine-state whose promise-type is `Promise`.

We need to define a new coroutine-state base-class that inherits from `__coroutine_state` and which contains the promise object so we can then define all coroutine-state types that use a particular promise-type to inherit from this base-class.

> 对于更通用的 `coroutine_handle<Promise>` 特殊化，大多数实现都可以重复使用 `coroutine_handle<void>` 实现。不过，我们还需要能够访问从 `promise()` 方法返回的协程状态的 promise 对象，并从对 promise 对象的引用中构造一个 `coroutine_handle` 。
>
> 然而，我们同样不能简单地指向具体的协程状态类型，因为 `coroutine_handle<Promise>` 类型必须能够引用任何 promise-type 为 `Promise` 的协程状态。
>
> 我们需要定义一个新的协程状态基类，它继承自 `__coroutine_state`，并包含 promise 对象，这样我们就可以定义所有使用特定 promise-type 的协程状态类型，使其继承自该基类。

```c++
template<typename Promise>
struct __coroutine_state_with_promise : __coroutine_state {
    __coroutine_state_with_promise() noexcept {}
    ~__coroutine_state_with_promise() {}

    union {
        Promise __promise;
    };
};
```

You might be wondering why we declare the `__promise` member inside an anonymous union here…

The reason for this is that the derived class created for a particular coroutine function contains the definition for the argument-copy data-members. Data members from derived classes are by default initialised after data-members of any base-classes, so declaring the promise object as a normal data-member would mean that the promise object was constructed before the argument-copy data-members.

However, we need the constructor of the promise to be called *after* the constructor of the argument-copies - references to the argument-copies might need to be passed to the promise constructor.

> 您可能想知道为什么我们要在匿名联合体中声明 `__promise` 成员
>
> 原因是为特定协程函数创建的派生类包含了参数拷贝数据成员的定义。派生类的数据成员默认在基类的数据成员之后初始化，因此将 promise 对象声明为普通数据成员将意味着 promise 对象是在参数复制数据成员之前构造的。
>
> 但是，我们需要在参数副本的构造函数之后调用 promise 的构造函数 - 可能需要将参数副本的引用传递给 promise 构造函数。

So we reserve storage for the promise object in this base-class so that it has a consistent offset from the start of the coroutine-state, but leave the derived class responsible for calling the constructor/destructor at the appropriate point after the argument-copies have been initialised. Declaring the `__promise` as a union-member provides this control.

Let’s update the `__g_state` class to now inherit from this new base-class.

> 因此，我们在基类中为 promise 对象保留了存储空间，使其与协程状态的开始处有一致的偏移量，但让派生类负责在参数副本初始化后的适当位置调用构造函数/析构函数。将 `__promise` 声明为联合成员就可以实现这种控制。
>
> 让我们更新 `__g_state` 类，使其继承于这个新的基类。

```C++
struct __g_state : __coroutine_state_with_promise<__g_promise_t> {
    __g_state(int&& __x)
    : x(static_cast<int&&>(__x)) {
        // Use placement-new to initialise the promise object in the base-class
        ::new ((void*)std::addressof(this->__promise))
            __g_promise_t(construct_promise<__g_promise_t>(x));
    }

    ~__g_state() {
        // Also need to manually call the promise destructor before the
        // argument objects are destroyed.
        this->__promise.~__g_promise_t();
    }

    int __suspend_point = 0;
    int x;
    manual_lifetime<std::suspend_always> __tmp1;
    // to be filled out
};
```

Now that we have defined the promise-base-class we can now implement the `std::coroutine_handle<Promise>` class template.

Most of the implementation should be largely identical to the equivalent methods in `coroutine_handle<void>` except with a `__coroutine_state_with_promise<Promise>` pointer instead of `__coroutine_state` pointer.

> 既然我们已经定义了 promise-base-class，现在就可以实现 `std::coroutine_handle<Promise>` 类模板了。
>
> 除了使用 `__coroutine_state_with_promise<Promise>` 指针而不是 `__coroutine_state` 指针外，大部分实现应该与 `coroutine_handle<void>` 中的等价方法基本相同。

The only new part is the addition of the `promise()` and `from_promise()` functions.

- The `promise()` method is straight-forward - it just returns a reference to the `__promise` member of the coroutine-state.

- The `from_promise()` method requires us to calculate the address of the coroutine-state from the address of the promise object. We can do this by just subtracting the offset of the `__promise` member from the address of the promise object.

Implementation of `coroutine_handle<Promise>`:

> 唯一新增的部分是添加了 `promise()` 和 `from_promise()` 函数。
>
> `promise()` 方法很简单——它只是返回对协程状态的 `__promise` 成员的引用。
>
> `from_promise()`方法要求我们从 promise 对象的地址计算出协程状态的地址。我们只需从 promise 对象的地址中减去 `__promise` 成员的偏移量即可。
>
> 实现 `coroutine_handle<Promise>`：

```c++
namespace std
{
    template<typename Promise>
    class coroutine_handle {
        using state_t = __coroutine_state_with_promise<Promise>;
    public:
        coroutine_handle() noexcept = default;
        coroutine_handle(const coroutine_handle&) noexcept = default;
        coroutine_handle& operator=(const coroutine_handle&) noexcept = default;

        operator coroutine_handle<void>() const noexcept {
            return coroutine_handle<void>::from_address(address());
        }

        explicit operator bool() const noexcept {
            return state_ != nullptr;
        }

        friend bool operator==(coroutine_handle a, coroutine_handle b) noexcept {
            return a.state_ == b.state_;
        }

        void* address() const {
            return static_cast<void*>(static_cast<__coroutine_state*>(state_));
        }

        static coroutine_handle from_address(void* ptr) {
            coroutine_handle h;
            h.state_ = static_cast<state_t*>(static_cast<__coroutine_state*>(ptr));
            return h;
        }

        Promise& promise() const {
            return state_->__promise;
        }

        static coroutine_handle from_promise(Promise& promise) {
            coroutine_handle h;

            // We know the address of the __promise member, so calculate the
            // address of the coroutine-state by subtracting the offset of
            // the __promise field from this address.
            h.state_ = reinterpret_cast<state_t*>(
                reinterpret_cast<unsigned char*>(std::addressof(promise)) -
                offsetof(state_t, __promise));

            return h;
        }

        // Define these in terms of their `coroutine_handle<void>` implementations

        void resume() const {
            static_cast<coroutine_handle<void>>(*this).resume();
        }

        void destroy() const {
            static_cast<coroutine_handle<void>>(*this).destroy();
        }

        bool done() const {
            return static_cast<coroutine_handle<void>>(*this).done();
        }

    private:
        state_t* state_;
    };
}
```

Now that we have defined the mechanism by which coroutines are resumed, we can now return to our “ramp” function and update it to initialise the new function-pointer data-members we’ve added to the coroutine-state.

> 既然我们已经定义了协程恢复的机制，现在就可以返回 "过渡 "函数，更新它以初始化我们添加到协程状态中的新函数指针数据成员。

# Step 8: The beginnings of the coroutine body

Let’s now forward-declare resume/destroy functions of the right signature and update the `__g_state` constructor to initialise the coroutine-state so that the resume/destroy function-pointers point at them:

> 现在让我们向前声明具有正确签名的 resume/destroy 函数，并更新 `__g_state` 构造函数以初始化协程状态，从而使 resume/destroy 函数指针指向它们：

```c++
void __g_resume(__coroutine_state* s);
void __g_destroy(__coroutine_state* s);

struct __g_state : __coroutine_state_with_promise<__g_promise_t> {
    __g_state(int&& __x)
    : x(static_cast<int&&>(__x)) {
        // Initialise the function-pointers used by coroutine_handle methods.
        this->__resume = &__g_resume;
        this->__destroy = &__g_destroy;

        // Use placement-new to initialise the promise object in the base-class
        ::new ((void*)std::addressof(this->__promise))
            __g_promise_t(construct_promise<__g_promise_t>(x));
    }

    // ... rest omitted for brevity
};


task g(int x) {
    std::unique_ptr<__g_state> state(new __g_state(static_cast<int&&>(x)));
    decltype(auto) return_value = state->__promise.get_return_object();

    state->__tmp1.construct_from([&]() -> decltype(auto) {
        return state->__promise.initial_suspend();
    });
    if (!state->__tmp1.get().await_ready()) {
        state->__tmp1.get().await_suspend(
            std::coroutine_handle<__g_promise_t>::from_promise(state->__promise));
        state.release();
        // fall through to return statement below.
    } else {
        // Coroutine did not suspend. Start executing the body immediately.
        __g_resume(state.release());
    }
    return return_value;
}
```

This now completes the ramp function and we can now focus on the resume/destroy functions for `g()`.

Let’s start by completing the lowering of the initial-suspend expression.

When `__g_resume()` is called and the `__suspend_point` index is 0 then we need it to resume by calling `await_resume()` on `__tmp1` and then calling the destructor of `__tmp1`.

> 这样，过渡函数就完成了，现在我们可以把注意力集中在 g() 的恢复/销毁函数上。
>
> 我们先来完成初始暂停表达式的转换。
>
> 当调用 `__g_resume() `且 `__suspend_point` 索引为 0 时，我们需要在 `__tmp1` 上调用 `await_resume()`，然后调用 `__tmp1` 的析构函数来恢复。

```C++
void __g_resume(__coroutine_state* s) {
    // We know that 's' points to a __g_state.
    auto* state = static_cast<__g_state*>(s);

    // Generate a jump-table to jump to the correct place in the code based
    // on the value of the suspend-point index.
    switch (state->__suspend_point) {
    	case 0: goto suspend_point_0;
    	default: std::unreachable();
	}

suspend_point_0:
    state->__tmp1.get().await_resume();
    state->__tmp1.destroy();

    // TODO: Implement rest of coroutine body.
    //
    //  int fx = co_await f(x);
    //  co_return fx * fx;
}
```

And when `__g_destroy()` is called and the `__suspend_point` index is 0 then we need it to just destroy `__tmp1` before then destroying and freeing the coroutine-state.

> 当调用`__g_destroy()`时，如果`__suspend_point` 索引为 0，那么我们需要它先销毁`__tmp1`，然后再销毁和释放协程状态。

```C++
void __g_destroy(__coroutine_state* s) {
    auto* state = static_cast<__g_state*>(s);

    switch (state->__suspend_point) {
    case 0: goto suspend_point_0;
    default: std::unreachable();
    }

suspend_point_0:
    state->__tmp1.destroy();
    goto destroy_state;

    // TODO: Add extra logic for other suspend-points here.

destroy_state:
    delete state;
}
```

# Step 9: Lowering the `co_await` expression

Next, let’s take a look at lowering the `co_await f(x)` expression.

First we need to evaluate `f(x)` which returns a temporary `task` object.

As the temporary `task` is not destroyed until the semicolon at the end of the statement and the statement contains a `co_await` expression, the lifetime of the `task` therefore spans a suspend-point and so it must be stored in the coroutine-state.

> 接下来，让我们看看如何转换`co_await f(x)`表达式。
>
> 首先，我们需要对 `f(x)`求值，它将返回一个临时任务对象。
>
> 由于临时`task`对象直到语句末尾的分号才会被销毁，而且语句中包含 co_await 表达式，因此该任务的生命周期跨越了一个暂停点，所以必须将其存储在协程状态中。

When the `co_await` expression is then evaluated on this temporary `task`, we need to call the `operator co_await()` method which returns a temporary `awaiter` object. The lifetime of this object also spans the suspend-point and so must be stored in the coroutine-state.

Let’s add the necessary members to the `__g_state` type:

> 当对这个临时任务执行 `co_await`表达式时，我们需要调用 `operator co_await()`方法，该方法会返回一个临时的 `awaiter `对象。该对象的生命周期也跨越暂停点，因此必须存储在协程状态中。
>
> 让我们为 `__g_state` 类型添加必要的成员：

```C++
struct __g_state : __coroutine_state_with_promise<__g_promise_t> {
    __g_state(int&& __x);
    ~__g_state();

    int __suspend_point = 0;
    int x;
    manual_lifetime<std::suspend_always> __tmp1;
    manual_lifetime<task> __tmp2;
    manual_lifetime<task::awaiter> __tmp3;
};
```

Then we can update the `__g_resume()` function to initialise these temporaries and then evaluate the 3 `await_ready`, `await_suspend` and `await_resume` calls that comprise the rest of the `co_await` expression.

Note that the `task::awaiter::await_suspend()` method returns a coroutine-handle so we need to generate code that resumes the returned handle.

We also need to update the suspend-point index before calling `await_suspend()` (we’ll use the index 1 for this suspend-point) and then add an extra entry to the jump-table to ensure that we resume back at the right spot.

> 然后，我们可以更新 `__g_resume()`函数来初始化这些临时对象，然后对构成 `co_await` 表达式其余部分的 3 个 `await_ready`、`await_suspend` 和 `await_resume` 调用求值。
>
> 请注意，`task::awaiter::await_suspend()` 方法会返回一个协程句柄，因此我们需要生成恢复返回句柄的代码。
>
> 我们还需要在调用 `await_suspend()` 之前更新暂停点索引（我们将使用索引 1 来表示这个暂停点），然后在跳转表中添加一个额外的条目，以确保我们恢复到正确的位置。

```C++
void __g_resume(__coroutine_state* s) {
    // We know that 's' points to a __g_state.
    auto* state = static_cast<__g_state*>(s);

    // Generate a jump-table to jump to the correct place in the code based
    // on the value of the suspend-point index.
    switch (state->__suspend_point) {
    case 0: goto suspend_point_0;
    case 1: goto suspend_point_1; // <-- add new jump-table entry
    default: std::unreachable();
    }

suspend_point_0:
    state->__tmp1.get().await_resume();
    state->__tmp1.destroy();

    //  int fx = co_await f(x);
    state->__tmp2.construct_from([&] {
        return f(state->x);
    });
    state->__tmp3.construct_from([&] {
        return static_cast<task&&>(state->__tmp2.get()).operator co_await();
    });
    if (!state->__tmp3.get().await_ready()) {
        // mark the suspend-point
        state->__suspend_point = 1;

        auto h = state->__tmp3.get().await_suspend(
            std::coroutine_handle<__g_promise_t>::from_promise(state->__promise));
        
        // Resume the returned coroutine-handle before returning.
        h.resume();
        return;
    }

suspend_point_1:
    int fx = state->__tmp3.get().await_resume();
    state->__tmp3.destroy();
    state->__tmp2.destroy();

    // TODO: Implement
    //  co_return fx * fx;
}
```

Note that the `int fx` local variable has a lifetime that does not span a suspend-point and so it does not need to be stored in the coroutine-state. We can just store it as a normal local variable in the `__g_resume` function.

We also need to add the necessary entry to the `__g_destroy()` function to handle when the coroutine is destroyed at this suspend-point.

> 请注意，`int fx` 这个局部变量的生命周期不跨越暂停点，因此它不需要存储在协程状态中。我们可以把它作为一个普通的局部变量保存在 `__g_resume` 函数中。
>
> 我们还需要在 `__g_destroy()` 函数中添加必要的条目，以处理当协程在此暂停点被销毁时的情况。

```C++
void __g_destroy(__coroutine_state* s) {
    auto* state = static_cast<__g_state*>(s);

    switch (state->__suspend_point) {
    case 0: goto suspend_point_0;
    case 1: goto suspend_point_1; // <-- add new jump-table entry
    default: std::unreachable();
    }

suspend_point_0:
    state->__tmp1.destroy();
    goto destroy_state;

suspend_point_1:
    state->__tmp3.destroy();
    state->__tmp2.destroy();
    goto destroy_state;

    // TODO: Add extra logic for other suspend-points here.

destroy_state:
    delete state;
}
```

So now we have finished implementing the statement:

> 所以现在我们已经实现了这个语句

```C++
int fx = co_await f(x);
```

However, the function `f(x)` is not marked `noexcept` and so it can potentially throw an exception. Also, the `awaiter::await_resume()` method is also not marked `noexcept` and can also potentially throw an exception.

When an exception is thrown from a coroutine-body the compiler generates code to catch the exception and then invoke `promise.unhandled_exception()` to give the promise an opportunity to do something with the exception. Let’s look at implementing this aspect next.

> 然而，函数 `f(x)` 并未标记为 `noexcept`，因此有可能抛出异常。此外，`awaiter::await_resume()` 方法也没有标记为`noexcept`，因此也可能抛出异常。
>
> 当协程体抛出异常时，编译器会生成捕获异常的代码，然后调用 `promise.unhandled_exception()` 给 promise 一个处理异常的机会。接下来让我们看看这方面的实现。

# Step 10: Implementing `unhandled_exception()`

The specification for coroutine definitions `[[dcl.fct.def.coroutine\]](https://eel.is/c++draft/dcl.fct.def.coroutine)` says that the coroutine behaves as if its function-body were replaced by:

> 协程定义的规范[[dcl.fct.def.coroutine\]](https://eel.is/c++draft/dcl.fct.def.coroutine)，协程的行为就好像它的函数体被替换了一样：

```C++
{
    promise-type promise promise-constructor-arguments ;
    try {
        co_await promise.initial_suspend() ;
        function-body
    } catch ( ... ) {
        if (!initial-await-resume-called)
            throw ;
        promise.unhandled_exception() ;
    }
final-suspend :
    co_await promise.final_suspend() ;
}
```

We have already handled the `initial-await_resume-called` branch separately in the ramp function, so we don’t need to worry about that here.

Let’s adjust the `__g_resume()` function to insert the try/catch block around the body.

Note that we need to be careful to put the `switch` that jumps to the right place inside the try-block as we are not allowed to enter a try-block using a `goto`.

> 我们已经在过渡函数中单独处理了 `initial-await_resume-called` 分支，所以这里不需要担心这个问题。
>
> 让我们调整 `__g_resume()` 函数，在主体周围插入 try/catch 块。
>
> 请注意，我们需要小心地将跳转到正确位置的 `switch` 放在 try 块内，因为我们不能使用 `goto` 进入 try 块。

Also, we need to be careful to call `.resume()` on the coroutine handle returned from `await_suspend()` outside of the try/catch block. If an exception is thrown from the call `.resume()` on the returned coroutine then it should not be caught by the current coroutine, but should instead propagate out of the call to `resume()` that resumed this coroutine. So we stash the coroutine-handle in a variable declared at the top of the function and then `goto` a point outside of the try/catch and execute the call to `.resume()` there.

> 此外，我们需要注意在 try/catch 块之外对 `await_suspend()`返回的协程句柄调用 `.resume()`。如果对返回的协程调用 `.resume()` 抛出异常，则当前协程不应捕获该异常，而应将其传播到恢复该协程的 `resume()` 调用之外。因此，我们将协程句柄存放在函数顶部声明的变量中，然后转到 try/catch 之外的一个点，在那里执行对 `.resume()` 的调用。

```C++
void __g_resume(__coroutine_state* s) {
    auto* state = static_cast<__g_state*>(s);

    std::coroutine_handle<void> coro_to_resume;

    try {
        switch (state->__suspend_point) {
        case 0: goto suspend_point_0;
        case 1: goto suspend_point_1; // <-- add new jump-table entry
        default: std::unreachable();
        }

suspend_point_0:
        state->__tmp1.get().await_resume();
        state->__tmp1.destroy();

        //  int fx = co_await f(x);
        state->__tmp2.construct_from([&] {
            return f(state->x);
        });
        state->__tmp3.construct_from([&] {
            return static_cast<task&&>(state->__tmp2.get()).operator co_await();
        });
        
        if (!state->__tmp3.get().await_ready()) {
            state->__suspend_point = 1;
            coro_to_resume = state->__tmp3.get().await_suspend(
                std::coroutine_handle<__g_promise_t>::from_promise(state->__promise));
            goto resume_coro;
        }

suspend_point_1:
        int fx = state->__tmp3.get().await_resume();
        state->__tmp3.destroy();
        state->__tmp2.destroy();

        // TODO: Implement
        //  co_return fx * fx;
    } catch (...) {
        state->__promise.unhandled_exception();
        goto final_suspend;
    }

final_suspend:
    // TODO: Implement
    // co_await promise.final_suspend();

resume_coro:
    coro_to_resume.resume();
    return;
}
```

There is a bug in the above code, however. In the case that the `__tmp3.get().await_resume()` call exits with an exception, we would fail to call the destructors of `__tmp3` and `__tmp2` before catching the exception.

Note that we cannot simply catch the exception, call the destructors and rethrow the exception here as this would change the behaviour of those destructors if they were to call `std::unhandled_exceptions()` since the exception would be “handled”. However if the destructor calls this during exception unwind, then call to `std:::unhandled_exceptions()` should return non-zero.

We can instead define an RAII helper class to ensure that the destructors get called on scope exit in the case an exception is thrown.

> 然而，上述代码中存在一个错误。如果 `__tmp3.get().await_resume()`调用出现异常退出，我们将无法在捕获异常之前调用 `__tmp3`和`__tmp2`的析构函数。
>
> 请注意，我们不能简单地捕获异常、调用析构函数并在此重新抛出异常，因为如果这些析构函数调用 std::unhandled_exceptions()，就会改变它们的行为，因为异常将被 "处理"。不过，如果析构函数在释放异常时调用此函数，那么调用 std:: unhandled_exceptions()时的返回值应该不会为零。
>
> 我们可以定义一个 RAII 辅助类，以确保在发生异常时，析构函数会在作用域退出时被调用。

```C++
template<typename T>
struct destructor_guard {
    explicit destructor_guard(manual_lifetime<T>& obj) noexcept
    : ptr_(std::addressof(obj))
    {}

    // non-movable
    destructor_guard(destructor_guard&&) = delete;
    destructor_guard& operator=(destructor_guard&&) = delete;

    ~destructor_guard() noexcept(std::is_nothrow_destructible_v<T>) {
        if (ptr_ != nullptr) {
            ptr_->destroy();
        }
    }

    void cancel() noexcept { ptr_ = nullptr; }

private:
    manual_lifetime<T>* ptr_;
};

// Partial specialisation for types that don't need their destructors called.
template<typename T>
    requires std::is_trivially_destructible_v<T>
struct destructor_guard<T> {
    explicit destructor_guard(manual_lifetime<T>&) noexcept {}
    void cancel() noexcept {}
};

// Class-template argument deduction to simplify usage
template<typename T>
destructor_guard(manual_lifetime<T>& obj) -> destructor_guard<T>;
```

Using this utility, we can now use this type to ensure that variables stored in the coroutine-state are destroyed when an exception is thrown.

Let’s also use this class to call the destructors of the existing varibles so that it also calls their destructors when they naturally go out of scope.

> 利用这个实用工具，我们现在可以使用这个类型来确保存储在协程状态中的变量在异常抛出时被销毁。
>
> 我们还可以使用该类来调用现有变量的析构函数，这样当它们自然退出作用域时，也会调用它们的析构函数。

```C++
void __g_resume(__coroutine_state* s) {
    auto* state = static_cast<__g_state*>(s);

    std::coroutine_handle<void> coro_to_resume;

    try {
        switch (state->__suspend_point) {
        case 0: goto suspend_point_0;
        case 1: goto suspend_point_1; // <-- add new jump-table entry
        default: std::unreachable();
        }

suspend_point_0:
        {
            destructor_guard tmp1_dtor{state->__tmp1};
            state->__tmp1.get().await_resume();
        }

        //  int fx = co_await f(x);
        {
            state->__tmp2.construct_from([&] {
                return f(state->x);
            });
            destructor_guard tmp2_dtor{state->__tmp2};

            state->__tmp3.construct_from([&] {
                return static_cast<task&&>(state->__tmp2.get()).operator co_await();
            });
            destructor_guard tmp3_dtor{state->__tmp3};

            if (!state->__tmp3.get().await_ready()) {
                state->__suspend_point = 1;

                coro_to_resume = state->__tmp3.get().await_suspend(
                    std::coroutine_handle<__g_promise_t>::from_promise(state->__promise));

                // A coroutine suspends without exiting scopes.
                // So cancel the destructor-guards.
                tmp3_dtor.cancel();
                tmp2_dtor.cancel();

                goto resume_coro;
            }

            // Don't exit the scope here.
            //
            // We can't 'goto' a label that enters the scope of a variable with a
            // non-trivial destructor. So we have to exit the scope of the destructor
            // guards here without calling the destructors and then recreate them after
            // the `suspend_point_1` label.
            tmp3_dtor.cancel();
            tmp2_dtor.cancel();
        }

suspend_point_1:
        int fx = [&]() -> decltype(auto) {
            destructor_guard tmp2_dtor{state->__tmp2};
            destructor_guard tmp3_dtor{state->__tmp3};
            return state->__tmp3.get().await_resume();
        }();

        // TODO: Implement
        //  co_return fx * fx;
    } catch (...) {
        state->__promise.unhandled_exception();
        goto final_suspend;
    }

final_suspend:
    // TODO: Implement
    // co_await promise.final_suspend();

resume_coro:
    coro_to_resume.resume();
    return;
}
```

Now our coroutine body will now destroy local variables correctly in the presence of any exceptions and will correctly call `promise.unhandled_exception()` if those exceptions propagate out of the coroutine body.

It’s worth noting here that there can also be special handling needed for the case where the `promise.unhandled_exception()` method itself exits with an exception (e.g. if it rethrows the current exception).

> 现在，我们的协程主体将在出现任何异常时正确地销毁局部变量，并且在这些异常传播出协程主体时正确地调用 `promise.unhandled_exception()`。
>
> 值得注意的是，在 `promise.unhandled_exception()` 方法本身带异常退出的情况下（例如，如果它重新抛出当前异常），也需要进行特殊处理。

In this case, the coroutine would need to catch the exception, mark the coroutine as suspended at a final-suspend-point, and then rethrow the exception.

For example: The `__g_resume()` function’s catch-block would need to look like this:

> 在这种情况下，协程需要捕获异常，在最终暂停点将协程标记为暂停，然后重新抛出异常。
>
> 例如 `__g_resume()` 函数的捕获块应该是这样的

```C++
try {
  // ...
} catch (...) {
    try {
        state->__promise.unhandled_exception();
    } catch (...) {
        state->__suspend_point = 2;
        state->__resume = nullptr; // mark as final-suspend-point
        throw;
    }
}
```

and we’d need to add an extra entry to the `__g_destroy` function’s jump table:

> 我们需要在 `__g_destroy` 函数的跳转表中增加一个额外的条目：

```C++
switch (state->__suspend_point) {
case 0: goto suspend_point_0;
case 1: goto suspend_point_1;
case 2: goto destroy_state; // no variables in scope that need to be destroyed
                            // just destroy the coroutine-state object.
}
```

Note that in this case, the final-suspend-point is not necessarily the same suspend-point as the final-suspend-point as the `co_await promise.final_suspend()` suspend-point.

This is because the `promise.final_suspend()` suspend-point will often have some extra temporary objects related to the `co_await` expression which need to be destroyed when `coroutine_handle::destroy()` is called. Whereas, if `promise.unhandled_exception()` exits with an exception then those temporary objects will not exist and so won’t need to be destroyed by `coroutine_handle::destroy()`.

> 请注意，在这种情况下，final-suspend-point 与 `co_await promise.final_suspend()` 暂停点并不一定是同一个暂停点。
>
> 这是因为 `promise.final_suspend()` 暂停点通常会有一些与 `co_await` 表达式相关的额外临时对象，需要在调用 `coroutine_handle::destroy()` 时销毁。而如果 `promise.unhandled_exception()` 异常退出，则这些临时对象将不存在，因此无需被 `coroutine_handle::destroy()` 销毁。

# Step 11: Implementing `co_return`

The next step is to implement the `co_return fx * fx;` statement.

This is relatively straight-forward compared to some of the previous steps.

The `co_return <expr>` statement gets mapped to:

> 下一步是实现 `co_return fx * fx;` 语句。
>
> 与前面的一些步骤相比，这一步相对简单。
>
> `co_return <expr>` 语句被映射为

```C++
promise.return_value(<expr>);
goto final-suspend-point;
```

So we can simply replace the TODO comment with:

> 因此，我们只需将 TODO 注释替换为

```C++
state->__promise.return_value(fx * fx);
goto final_suspend;
```

Easy.

> 太简单了

# Step 12: Implementing `final_suspend()`

The final TODO in the code is now to implement the `co_await promise.final_suspend()` statement.

The `final_suspend()` method returns a temporary `task::promise_type::final_awaiter` type, which will need to be stored in the coroutine-state and destroyed in `__g_destroy`.

This type does not have its own `operator co_await()`, so we don’t need an additional temporary object for the result of that call.

Like the `task::awaiter` type, this also uses the coroutine-handle-returning form of `await_suspend()`. So we need to ensure that we call `resume()` on the returned handle.

> 现在，代码中的最后一个 TODO 是实现 `co_await promise.final_suspend()` 语句。
>
> `final_suspend()`方法返回一个临时的 `task::promise_type::final_awaiter` 类型，它需要存储在协程状态中，并在 `__g_destroy` 中销毁。
>
> 该类型没有自己的`operator co_await()`，因此我们不需要为该调用的结果再添加一个临时对象。
>
> 与 `task::awaiter` 类型一样，它也使用了 `await_suspend()` 的协程句柄返回形式。因此，我们需要确保在返回的句柄上调用 `resume()`。

If the coroutine does not suspend at the final-suspend-point then the coroutine-state is implicitly destroyed. So we need to delete the state object if execution reaches the end of the coroutine.

Also, as all of the final-suspend logic is required to be noexcept, we don’t need to worry about exceptions being thrown from any of the sub-expressions here.

Let’s first add the data-member to the `__g_state` type.

> 如果协程没有在最终暂停点暂停，那么协程状态就会被隐式销毁。因此，如果执行到协程结束，我们需要删除状态对象。
>
> 此外，由于所有的最终暂停逻辑都必须是 `noexcept`，因此我们不必担心这里的任何子表达式会抛出异常。
>
> 让我们首先为 `__g_state` 类型添加数据成员。

```C++
struct __g_state : __coroutine_state_with_promise<__g_promise_t> {
    __g_state(int&& __x);
    ~__g_state();

    int __suspend_point = 0;
    int x;
    manual_lifetime<std::suspend_always> __tmp1;
    manual_lifetime<task> __tmp2;
    manual_lifetime<task::awaiter> __tmp3;
    manual_lifetime<task::promise_type::final_awaiter> __tmp4; // <---
};
```

Then we can implement the body of the final-suspend expression as follows:

> 然后，我们可以按如下方式实现最终暂停表达式的主体：

```C++
final_suspend:
    // co_await promise.final_suspend
    {
        state->__tmp4.construct_from([&]() noexcept {
            return state->__promise.final_suspend();
        });
        destructor_guard tmp4_dtor{state->__tmp4};

        if (!state->__tmp4.get().await_ready()) {
            state->__suspend_point = 2;
            state->__resume = nullptr; // mark as final suspend-point

            coro_to_resume = state->__tmp4.get().await_suspend(
                std::coroutine_handle<__g_promise_t>::from_promise(state->__promise));

            tmp4_dtor.cancel();
            goto resume_coro;
        }

        state->__tmp4.get().await_resume();
    }

    //  Destroy coroutine-state if execution flows off end of coroutine
    delete state;
    return;
```

And now we also need to update the `__g_destroy` function to handle this new suspend-point.

> 现在，我们还需要更新 `__g_destroy` 函数，以处理这个新的暂停点。

```C++
void __g_destroy(__coroutine_state* state) {
    auto* state = static_cast<__g_state*>(s);

    switch (state->__suspend_point) {
    case 0: goto suspend_point_0;
    case 1: goto suspend_point_1;
    case 2: goto suspend_point_2;
    default: std::unreachable();
    }

suspend_point_0:
    state->__tmp1.destroy();
    goto destroy_state;

suspend_point_1:
    state->__tmp3.destroy();
    state->__tmp2.destroy();
    goto destroy_state;

suspend_point_2:
    state->__tmp4.destroy();
    goto destroy_state;

destroy_state:
    delete state;
}
```

We now have a fully functional lowering of the `g()` coroutine function.

We’re done! That’s it!

Or is it….

> 现在，我们有了一个功能完备的 g() 协程函数下限。
>
> 我们完成了！就是这样！
>
> 但是....

# Step 13: Implementing symmetric-transfer and the noop-coroutine

It turns out there is actually a problem with the way we have implemented our `__g_resume()` function above.

The problems with this were discussed in more detail in the previous blog post so if you want to understand the problem more deeply please take a look at the post [C++ Coroutines: Understanding Symmetric Transfer](https://lewissbaker.github.io/2020/05/11/understanding_symmetric_transfer).

The specification for [[expr.await]](https://eel.is/c++draft/expr.await) gives a little hint about how we should be handling the coroutine-handle-returning flavour of `await_suspend`:

> 事实证明，我们上面实现 __g_resume()函数的方法存在问题。
>
> 在上一篇博文中，我们已经详细讨论了其中的问题，如果你想更深入地了解这个问题，请阅读《C++ 协程： 了解对称传输》。
>
> [[expr.await]](https://eel.is/c++draft/expr.await)的规范给出了一点提示，告诉我们应该如何处理await_suspend的协程句柄返回方式：

> If the type of *await-suspend* is `std::coroutine_­handle<Z>`, *await-suspend*`.resume()` is evaluated.
>
> > 如果 *await-suspend* 的类型是 `std::coroutine_handle<Z>`，则会对 `await-suspend.resume()`求值。

[*Note* 1: This resumes the coroutine referred to by the result of *await-suspend*. Any number of coroutines can be successively resumed in this fashion, eventually returning control flow to the current coroutine caller or resumer ([[dcl.fct.def.coroutine]](https://eel.is/c++draft/dcl.fct.def.coroutine)). —- *end note*]

The note there, while non-normative and thus non-binding, is strongly encouraging compilers to  implement this in such a way that it performs a tail-call to resume the next coroutine rather than resuming the next coroutine recursively. This is because resuming the next coroutine recursively can easily lead to unbounded stack growth if coroutines resume each other in a loop.

The problem is that we are calling `.resume()` on the next coroutine from within the body of the `__g_resume()` function and then returning, so the stack space used by the `__g_resume()` frame is not freed until after the next coroutine suspends and returns.

> 该注释虽然不具有规范性，因此也不具有约束力，但它强烈鼓励编译器在实现时执行尾调用以恢复下一个协程，而不是递归恢复下一个协程。这是因为如果协程在循环中相互恢复，递归恢复下一个协程很容易导致堆栈无限制增长。
>
> 问题在于我们是在 `__g_resume()` 函数的主体中调用下一个协程的 `.resume()` 然后返回的，因此 `__g_resume()` 帧使用的栈空间直到下一个协程暂停并返回后才被释放。

Compilers are able to do this by implementing the resumption of the next coroutine as a tail-call. In this way, the compiler generates code that first pops the the current stack frame, preserving the return-address, and then executes a `jmp` to the next coroutine’s resume-function.

As we don’t have a mechanism in C++ to specify that a function-call in the tail-position should be a tail-call we will need to instead actually return from the resume-function so that its stack-space can be freed, and then have the caller resume the next coroutine.

> 编译器可以通过将下一个协程的恢复作为尾调用来实现。这样，编译器生成的代码首先弹出当前堆栈帧，保留返回地址，然后执行 jmp 到下一个协程的恢复函数。
>
> 由于 C++ 中没有机制指定尾调用位置的函数应该是尾调用，因此我们需要从 resume-function 中实际返回，以便释放其栈空间，然后让调用者恢复下一个协程。

As the next coroutine may also need to resume another coroutine when it suspends, and this may happen indefinitely, the caller will need to resume the coroutines in a loop.

Such a loop is typically called a “trampoline loop” as we return back to the loop from one coroutine and then “bounce” off the loop back into the next coroutine.

> 由于下一个协程在暂停时可能还需要恢复另一个协程，而且这种情况可能会无限期地发生，因此调用者需要在一个循环中恢复协程。
>
> 这样的循环通常被称为 "蹦床循环"，因为我们从一个协程返回循环，然后从循环中 "弹跳 "回下一个协程。

If we modify the signature of the resume-function to return a pointer to the next coroutine’s coroutine-state instead of returning void, then the `coroutine_handle::resume()` function can then just immediately call the `__resume()` function-pointer for the next coroutine to resume it.

Let’s change the signature of the `__resume_fn` for a `__coroutine_state`:

> 如果我们修改 resume-function 的签名，使其返回下一个协程的协程状态指针，而不是返回`void`，那么 `coroutine_handle::resume()` 函数就可以立即调用下一个协程的`__resume()`函数指针来恢复它。
>
> 让我们把 `__resume_fn` 的签名改为 `__coroutine_state`：

```C++
struct __coroutine_state {
    using __resume_fn = __coroutine_state* (__coroutine_state*);
    using __destroy_fn = void (__coroutine_state*);

    __resume_fn* __resume;
    __destroy_fn* __destroy;
};
```

Then we can write the `coroutine_handle::resume()` function something like this:

> 然后，我们可以这样编写 `coroutine_handle::resume()` 函数：

```C++
void std::coroutine_handle<void>::resume() const {
    __coroutine_state* s = state_;
    do {
        s = s->__resume(s);
    } while (/* some condition */);
}
```

The next question then becomes: “What should the condition be?”

This is where the `std::noop_coroutine()` helper comes into the picture.

The `std::noop_coroutine()` is a factory function that returns a special coroutine handle that has a no-op `resume()` and `destroy()` method. If a coroutine suspends and returns the noop-coroutine-handle from the `await_suspend()` method then this indicates that there is no more coroutine to resume and that the invocation of `coroutien_handle::resume()` that resumed this coroutine should return to its caller.

> 接下来的问题就变成了：条件应该是什么？
>
> 这时就需要使用 `std::noop_coroutine()` 辅助函数了。
>
> `std::noop_coroutine()` 是一个工厂函数，它返回一个特殊的协程句柄，该句柄具有无操作的 `resume()` 和 `destroy()` 方法。如果一个协程暂停并从 `await_suspend()` 方法返回 `noop-coroutine` 句柄，那么这表明没有更多的协程需要恢复，恢复该协程的 `coroutien_handle::resume()` 的调用应该返回给它的调用者。

So we need to implement `std::noop_coroutine()` and the condition in `coroutine_handle::resume()` so that the condition returns false and the loop exits when the `__coroutine_state` pointer points to the noop-coroutine-state.

One strategy we can use here is to define a static instance of `__coroutine_state` that is designated as the noop-coroutine-state. The `std::noop_coroutine()` function can return a coroutine-handle that points to this object, and we can compare the `__coroutine_state` pointer to the address of that object to see if a particular coroutine handle is the noop-coroutine.

First let’s define this special noop-coroutine-state object:

> 因此，我们需要实现 `std::noop_coroutine()` 和 `coroutine_handle::resume()` 中的条件，以便当 `__coroutine_state` 指针指向 `noop-coroutine-state` 时，条件返回 false，循环退出。
>
> 在这里，我们可以使用的一种策略是定义一个 `__coroutine_state` 的静态实例，将其指定为 `noop-coroutine-state`。`std::noop_coroutine()` 函数可以返回一个指向这个对象的协程句柄，我们可以比较 `__coroutine_state` 指针和这个对象的地址，看看某个特定的协程句柄是否就是 `noop-coroutine`。
>
> 首先让我们定义这个特殊的 `noop-coroutine-state` 对象：

```C++
struct __coroutine_state {
    using __resume_fn = __coroutine_state* (__coroutine_state*);
    using __destroy_fn = void (__coroutine_state*);

    __resume_fn* __resume;
    __destroy_fn* __destroy;

    static __coroutine_state* __noop_resume(__coroutine_state* state) noexcept {
        return state;
    }

    static void __noop_destroy(__coroutine_state*) noexcept {}

    static const __coroutine_state __noop_coroutine;
};

inline const __coroutine_state __coroutine_state::__noop_coroutine{
    &__coroutine_state::__noop_resume,
    &__coroutine_state::__noop_destroy
};
```

Then we can implement the `std::coroutine_handle<noop_coroutine_promise>` specialisation.

> 然后，我们就可以实现 `std::coroutine_handle<noop_coroutine_promise>` 特殊化。

```C++
namespace std
{
    struct noop_coroutine_promise {};

    using noop_coroutine_handle = coroutine_handle<noop_coroutine_promise>;

    noop_coroutine_handle noop_coroutine() noexcept;

    template<>
    class coroutine_handle<noop_coroutine_promise> {
    public:
        constexpr coroutine_handle(const coroutine_handle&) noexcept = default;
        constexpr coroutine_handle& operator=(const coroutine_handle&) noexcept = default;

        constexpr explicit operator bool() noexcept { return true; }

        constexpr friend bool operator==(coroutine_handle, coroutine_handle) noexcept {
            return true;
        }

        operator coroutine_handle<void>() const noexcept {
            return coroutine_handle<void>::from_address(address());
        }

        noop_coroutine_promise& promise() const noexcept {
            static noop_coroutine_promise promise;
            return promise;
        }

        constexpr void resume() const noexcept {}
        constexpr void destroy() const noexcept {}
        constexpr bool done() const noexcept { return false; }

        constexpr void* address() const noexcept {
            return const_cast<__coroutine_state*>(&__coroutine_state::__noop_coroutine);
        }
    private:
        constexpr coroutine_handle() noexcept = default;

        friend noop_coroutine_handle noop_coroutine() noexcept {
            return {};
        }
    };
}
```

And we can update `coroutine_handle::resume()` to exit when the noop-coroutine-state is returned.

> 我们还可以更新 `coroutine_handle::resume()` ，以在返回 `noop-coroutine` 状态时退出。

```C++
void std::coroutine_handle<void>::resume() const {
    __coroutine_state* s = state_;
    do {
        s = s->__resume(s);
    } while (s != &__coroutine_state::__noop_coroutine);
}
```

And finally, we can update our `__g_resume()` function to now return the `__coroutine_state*`.

This just involves updating the signature and replacing:

> 最后，我们可以更新 `__g_resume()` 函数，使其返回 `__coroutine_state*`。
>
> 这只涉及更新签名和替换：

```C++
coro_to_resume = ...;
goto resume_coro;
```

with

> 以及

```C++
auto h = ...;
return static_cast<__coroutine_state*>(h.address());
```

and then at the very end of the function (after the `delete state;` statement) adding

> 然后在函数的最后（delete state; 语句之后）添加：

```C++
return static_cast<__coroutine_state*>(std::noop_coroutine().address());
```

# One last thing

Those with a keen eye may have noticed that the coroutine-state type `__g_state` is actually larger than it needs to be.

The data-members for the 4 temporary values each reserve storage for their respective values. However, the lifetimes of some of the temporary values do not overlap and so in theory we can save space in the coroutine-state by reusing the storage of an object for the next object after its lifetime has ended.

To be able to take advantage of this we can instead define the data-members in an anonymous union where appropriate.

> 细心的人可能已经注意到，协程状态类型 `__g_state` 实际上比需要的要大。
>
> 4 个临时值的数据成员都为各自的值保留了存储空间。然而，一些临时值的生命周期并不重叠，因此理论上我们可以通过在一个对象的生命周期结束后为下一个对象重复使用该对象的存储空间来节省协程状态的空间。
>
> 为了利用这一点，我们可以在适当的地方用匿名联合体来定义数据成员。

Looking at the lifetimes of the temporary varaibles we have:

> 看看我们拥有的临时变量的生命周期：

- `__tmp1` - exists only within `co_await promise.initial_suspend();` statement

- `__tmp2` - exists only within `int fx = co_await f(x);` statement

- `__tmp3` - exists only within `int fx = co_await f(x);` statement - nested inside lifetime of `__tmp2`

- `__tmp4` - exists only within `co_await promise.final_suspend();` statement

> `__tmp1` - 仅存在于 `co_await promise.initial_suspend();` 语句中
>
> `__tmp2` - 仅存在于 `int fx = co_await f(x);` 语句中
>
> `__tmp3` - 仅存在于 `int fx = co_await f(x);` 语句中 - 嵌套在 `__tmp2` 的生命周期内
>
> `__tmp4` - 仅存在于 `co_await promise.final_suspend();` 语句中

Since lifetimes of `__tmp2` and `__tmp3` overlap we must place them in a struct together as they both need to exist at the same time.

However, the `__tmp1` and `__tmp4` members do not have lifetimes that overlap and so they can be placed together in an anonymous `union`.

Thus we can change our data-member definition to:

> 由于 `__tmp2` 和 `__tmp3` 的生命周期重叠，我们必须把它们放在一个结构体中，因为它们需要同时存在。
>
> 然而，`__tmp1` 和`__tmp4` 成员的生命周期并不重叠，因此可以把它们放在一个匿名联合体中。
>
> 因此，我们可以将数据成员定义改为

```C++
struct __g_state : __coroutine_state_with_promise<__g_promise_t> {
    __g_state(int&& x);
    ~__g_state();

    int __suspend_point = 0;
    int x;

    struct __scope1 {
        manual_lifetime<task> __tmp2;
        manual_lifetime<task::awaiter> __tmp3;
    };

    union {
        manual_lifetime<std::suspend_always> __tmp1;
        __scope1 __s1;
        manual_lifetime<task::promise_type::final_awaiter> __tmp4;
    };
};
```

Then, because the `__tmp2` and `__tmp3` variables are now nested inside the `__s1` object, we need to update references to them to now be e.g. `state->__s1.tmp2`. But otherwise the rest of the code stays the same.

This should save an additional 16 bytes of the coroutine-state size as we no longer need extra storage + padding for the `__tmp1` and `__tmp4` data-members - which would otherwise be padded to the size of a pointer, despite being empty types.

> 然后，由于 `__tmp2` 和 `__tmp3` 变量现在嵌套在 `__s1` 对象中，我们需要更新对它们的引用，如 `state->__s1.tmp2`。除此之外，代码的其他部分保持不变。
>
> 这将额外节省 16 字节的协程状态大小，因为我们不再需要为 `__tmp1` 和 `__tmp4` 数据成员提供额外的存储空间和填充，否则，尽管它们是空类型，也会被填充为指针大小。

# Tying it all together

Ok, so the final code we have generated for the coroutine function:

> 好了，这就是我们为协程函数生成的最终代码：

```C++
task g(int x) {
    int fx = co_await f(x);
    co_return fx * fx;
}
```

is the following:

> 接下来：

```C++
/////
// The coroutine promise-type

using __g_promise_t = std::coroutine_traits<task, int>::promise_type;

__coroutine_state* __g_resume(__coroutine_state* s);
void __g_destroy(__coroutine_state* s);

/////
// The coroutine-state definition

struct __g_state : __coroutine_state_with_promise<__g_promise_t> {
    __g_state(int&& x)
    : x(static_cast<int&&>(x)) {
        // Initialise the function-pointers used by coroutine_handle methods.
        this->__resume = &__g_resume;
        this->__destroy = &__g_destroy;

        // Use placement-new to initialise the promise object in the base-class
        // after we've initialised the argument copies.
        ::new ((void*)std::addressof(this->__promise))
            __g_promise_t(construct_promise<__g_promise_t>(this->x));
    }

    ~__g_state() {
        this->__promise.~__g_promise_t();
    }

    int __suspend_point = 0;

    // Argument copies
    int x;

    // Local variables/temporaries
    struct __scope1 {
        manual_lifetime<task> __tmp2;
        manual_lifetime<task::awaiter> __tmp3;
    };

    union {
        manual_lifetime<std::suspend_always> __tmp1;
        __scope1 __s1;
        manual_lifetime<task::promise_type::final_awaiter> __tmp4;
    };
};

/////
// The "ramp" function

task g(int x) {
    std::unique_ptr<__g_state> state(new __g_state(static_cast<int&&>(x)));
    decltype(auto) return_value = state->__promise.get_return_object();

    state->__tmp1.construct_from([&]() -> decltype(auto) {
        return state->__promise.initial_suspend();
    });
    if (!state->__tmp1.get().await_ready()) {
        state->__tmp1.get().await_suspend(
            std::coroutine_handle<__g_promise_t>::from_promise(state->__promise));
        state.release();
        // fall through to return statement below.
    } else {
        // Coroutine did not suspend. Start executing the body immediately.
        __g_resume(state.release());
    }
    return return_value;
}

/////
//  The "resume" function

__coroutine_state* __g_resume(__coroutine_state* s) {
    auto* state = static_cast<__g_state*>(s);

    try {
        switch (state->__suspend_point) {
        case 0: goto suspend_point_0;
        case 1: goto suspend_point_1; // <-- add new jump-table entry
        default: std::unreachable();
        }

suspend_point_0:
        {
            destructor_guard tmp1_dtor{state->__tmp1};
            state->__tmp1.get().await_resume();
        }

        //  int fx = co_await f(x);
        {
            state->__s1.__tmp2.construct_from([&] {
                return f(state->x);
            });
            destructor_guard tmp2_dtor{state->__s1.__tmp2};

            state->__s1.__tmp3.construct_from([&] {
                return static_cast<task&&>(state->__s1.__tmp2.get()).operator co_await();
            });
            destructor_guard tmp3_dtor{state->__s1.__tmp3};

            if (!state->__s1.__tmp3.get().await_ready()) {
                state->__suspend_point = 1;

                auto h = state->__s1.__tmp3.get().await_suspend(
                    std::coroutine_handle<__g_promise_t>::from_promise(state->__promise));

                // A coroutine suspends without exiting scopes.
                // So cancel the destructor-guards.
                tmp3_dtor.cancel();
                tmp2_dtor.cancel();

                return static_cast<__coroutine_state*>(h.address());
            }

            // Don't exit the scope here.
            // We can't 'goto' a label that enters the scope of a variable with a
            // non-trivial destructor. So we have to exit the scope of the destructor
            // guards here without calling the destructors and then recreate them after
            // the `suspend_point_1` label.
            tmp3_dtor.cancel();
            tmp2_dtor.cancel();
        }

suspend_point_1:
        int fx = [&]() -> decltype(auto) {
            destructor_guard tmp2_dtor{state->__s1.__tmp2};
            destructor_guard tmp3_dtor{state->__s1.__tmp3};
            return state->__s1.__tmp3.get().await_resume();
        }();

        //  co_return fx * fx;
        state->__promise.return_value(fx * fx);
        goto final_suspend;
    } catch (...) {
        state->__promise.unhandled_exception();
        goto final_suspend;
    }

final_suspend:
    // co_await promise.final_suspend
    {
        state->__tmp4.construct_from([&]() noexcept {
            return state->__promise.final_suspend();
        });
        destructor_guard tmp4_dtor{state->__tmp4};

        if (!state->__tmp4.get().await_ready()) {
            state->__suspend_point = 2;
            state->__resume = nullptr; // mark as final suspend-point

            auto h = state->__tmp4.get().await_suspend(
                std::coroutine_handle<__g_promise_t>::from_promise(state->__promise));

            tmp4_dtor.cancel();
            return static_cast<__coroutine_state*>(h.address());
        }

        state->__tmp4.get().await_resume();
    }

    //  Destroy coroutine-state if execution flows off end of coroutine
    delete state;

    return static_cast<__coroutine_state*>(std::noop_coroutine().address());
}

/////
// The "destroy" function

void __g_destroy(__coroutine_state* s) {
    auto* state = static_cast<__g_state*>(s);

    switch (state->__suspend_point) {
    case 0: goto suspend_point_0;
    case 1: goto suspend_point_1;
    case 2: goto suspend_point_2;
    default: std::unreachable();
    }

suspend_point_0:
    state->__tmp1.destroy();
    goto destroy_state;

suspend_point_1:
    state->__s1.__tmp3.destroy();
    state->__s1.__tmp2.destroy();
    goto destroy_state;

suspend_point_2:
    state->__tmp4.destroy();
    goto destroy_state;

destroy_state:
    delete state;
}
```

For a fully compilable version of the final code, see: [https://godbolt.org/z/xaj3Yxabn](https://godbolt.org/z/xaj3Yxabn)

This concludes the 5-part series on understanding the mechanics of C++ coroutines.

This is probably more information than you ever wanted to know about coroutines, but hopefully it helps you to understand what’s going on under the hood and demystifies them just a bit.

Thanks for making it through to the end!

Until next time, Lewis.

> 有关最终代码的完全可编译版本，请参见： https://godbolt.org/z/xaj3Yxabn
>
> 关于了解 C++ 协程机制的 5 部分系列文章到此结束。
>
> 这些信息可能比你想了解的关于协程的信息还要多，但希望它能帮助你理解引擎盖下发生了什么，并稍微揭开它们的神秘面纱。
>
> 感谢你坚持到最后！
>
> 下次再见，Lewis。

---

### Comments

​        Comments are welcome in [this GitHub issue](https://github.com/lewissbaker/lewissbaker.github.io/issues/6)

