---
layout: post
title: C++协程：理解对称转移（译）
date: 2024-01-09
---

# C++ Coroutines: Understanding Symmetric Transfer

---

The Coroutines TS provided a wonderful way to write asynchronous code as if you were writing synchronous code. You just need to sprinkle `co_await` at appropriate points and the compiler takes care of suspending the coroutine, preserving state across suspend-points and resuming execution of the coroutine later when the operation completes.

However, the Coroutines TS, as it was originally specified, had a nasty limitation that could easily lead to stack-overflow if you weren’t careful. And if you wanted to avoid this stack-overflow then you had to introduce extra synchronisation overhead to safely guard against this in your `task<T>` type.

Thankfully, a tweak was made to the design of coroutines in 2018 to add a capability called “symmetric transfer” which allows you to suspend one coroutine and resume another coroutine without consuming any additional stack-space. The addition of this capability lifted a key limitation of the Coroutines TS and allows for much simpler and more efficient implementation of async coroutine types without sacrificing any of the safety aspects needed to guard against stack-overflow.

In this post I will attempt to explain the stack-overflow problem and how the addition of this key “symmetric transfer” capability lets us solve this problem.

> 协程 TS 为编写异步代码提供了一种绝妙的方法，就像编写同步代码一样。您只需在适当的地方写上 `co_await`，编译器就会负责暂停协程、保存跨暂停点的状态，并在稍后操作完成时恢复协程的执行。
>
> 然而，最初指定的协程 TS 有一个令人讨厌的限制：一不小心就很容易导致堆栈溢出。如果想避免堆栈溢出，就必须引入额外的同步开销，以便在 `task<T>`类型中安全地防范这种情况。
>
> 值得庆幸的是，2018 年对协程的设计进行了调整，增加了一种名为 "对称传输 "的功能，它允许你暂停一个协程并恢复另一个协程，而不会消耗任何额外的栈空间。这一能力的添加解除了 Coroutines TS 的一个关键限制，并允许更简单、更高效地实现异步协程类型，而不会牺牲防范堆栈溢出所需的任何安全方面。
>
> 在这篇文章中，我将尝试解释堆栈溢出问题，以及添加这一关键的 "对称传输 "功能是如何让我们解决这一问题的。

## First some background on how a task coroutine works

Consider the following coroutines:

> 考虑以下协程：

```C++
task foo() {
  co_return;
}

task bar() {
  co_await foo();
}
```

Assume we have a simple `task` type that lazily executes the body when another coroutine awaits it. This particular `task` type does not support returning a value.

> 假设我们有一个简单的 `task` 类型，当另一个协程等待它时，它会延迟执行主体。这种特殊的 `task` 类型不支持返回值。

Let’s unpack what’s happening here when `bar()` evaluates `co_await foo()`.

- The `bar()` coroutine calls the `foo()` function. Note that from the caller’s perspective a coroutine is just an ordinary function.
- The invocation of 

> 让我们来解读一下 `bar()` 求值 `coo_await foo()` 时发生了什么。
>
> - `bar()` 协程调用了 `foo()` 函数。请注意，从调用者的角度来看，协程只是一个普通函数。
> - 调用

```c++
foo()
```

 performs a few steps:    

- Allocates storage for a coroutine frame (typically on the heap)
- Copies parameters into the coroutine frame (in this case there are no parameters so this is a no-op).
- Constructs the promise object in the coroutine frame
- Calls `promise.get_return_object()` to get the return-value for `foo()`. This produces the `task` object that will be returned, initialising it with a `std::coroutine_handle` that refers to the coroutine frame that was just created.
- Suspends execution of the coroutine at the initial-suspend point (ie. the open curly brace)
- Returns the `task` object back to `bar()`.

> 执行几个步骤    
>
> - 为协程帧分配存储空间（通常在堆上）
> - 将参数复制到协程帧中（本例中没有参数，所以不执行此操作）。
> - 在协程帧中构造 promise 对象
> - 调用 `promise.get_return_object()` 获取 `foo()` 的返回值。这会生成将返回的 `task` 对象，并用指向刚刚创建的协程帧的 `std::coroutine_handle` 对其进行初始化。
> - 在初始-暂停点（即打开的大括号）暂停协程的执行
> - 将 `task` 对象返回给 `bar()`。

- Next the 

  ```plaintext
  bar()
  ```

   coroutine evaluates the 

  ```plaintext
  co_await
  ```

   expression on the 

  ```plaintext
  task
  ```

   returned from 

  ```plaintext
  foo()
  ```

  .    

  - The `bar()` coroutine suspends and then calls the `await_suspend()` method on the returned task, passing it the `std::coroutine_handle` that refers to `bar()`’s coroutine frame.
  - The `await_suspend()` method then stores `bar()`’s `std::coroutine_handle` in `foo()`’s promise object and then resumes the `foo()` coroutine by calling `.resume()` on `foo()`’s `std::coroutine_handle`.

  > - `bar()` 协程暂停，然后调用返回任务的 `await_suspend()` 方法，并将指向 `bar()` 协程帧的 `std::coroutine_handle` 传递给它。
  > - 然后，`await_suspend()` 方法将 `bar()` 的 `std::coroutine_handle` 保存在 `foo()` 的 promise 对象中，然后通过在 `foo()` 的 `std::coroutine_handle` 上调用 `.resume()` 来恢复 `foo()` 协程。

- The `foo()` coroutine executes and runs to completion synchronously.

- The `foo()` coroutine suspends at the final-suspend point (ie. the closing curly brace) and then resumes the coroutine identified by the `std::coroutine_handle` that was stored in its promise object before it was started. ie. `bar()`’s coroutine.

- The `bar()` coroutine resumes and continues executing and eventually reaches the end of the statement containing the `co_await` expression at which point it calls the destructor of the temporary `task` object returned from `foo()`.

- The `task` destructor then calls the `.destroy()` method on `foo()`’s coroutine handle which then destroys the coroutine frame along with the promise object and copies of any arguments.

> - `foo()`协程同步执行并运行至完成。
> - `foo()`协程在最后暂停点（即结尾大括号）暂停，然后恢复由`std::coroutine_handle`标识的协程，该协程在启动前存储在其 promise 对象中，即`bar()`的协程。
> - `bar()`的协程恢复并继续执行，最终到达包含`co_await`表达式的语句的末尾，此时它会调用从`foo()`返回的临时`task`对象的析构函数。
> - 然后，`task `析构函数会调用 `foo() `协程句柄上的`.destroy() `方法，从而销毁协程帧以及 promise 对象和所有参数的副本。

Ok, so that seems like a lot of steps for a simple call.

To help understand this in a bit more depth, let’s look at how a naive implementation of this `task` class would look when implemented using the the Coroutines TS design (which didn’t support symmetric transfer).

> 好吧，对于一个简单的调用来说，这似乎有很多步骤。
>
> 为了更深入地理解这个问题，让我们来看看使用协程 TS 设计（不支持对称传输）时，这个 "任务 "类的简单实现会是怎样的。

## Outline of  a `task` implementation

The outline of the class looks something like this:

> 类的大纲是这样的

```C++
class task {
public:
  class promise_type { /* see below */ };

  task(task&& t) noexcept
  : coro_(std::exchange(t.coro_, {}))
  {}

  ~task() {
    if (coro_)
      coro_.destroy();
  }

  class awaiter { /* see below */ };

  awaiter operator co_await() && noexcept;

private:
  explicit task(std::coroutine_handle<promise_type> h) noexcept
  : coro_(h)
  {}

  std::coroutine_handle<promise_type> coro_;
};
```

A `task` has exclusive ownership of the `std::coroutine_handle` that corresponds to the coroutine frame created during the invocation of the coroutine. The `task` object is an RAII object that ensures that `.destroy()` is called on the `std::coroutine_handle` when the `task` object goes out of scope.

So now let’s expand on the `promise_type`.

> `task` 对 `std::coroutine_handle `具有独占所有权，该 `std::coroutine_handle `与调用协程时创建的协程帧相对应。`task `对象是一个 RAII 对象，当 `task `对象退出作用域时，它可以确保在 `std::coroutine_handle `上调用`.destroy()`。
>
> 现在让我们进一步了解 `promise_type`。

## Implementing `task::promise_type`

From the [previous post](https://lewissbaker.github.io/2018/09/05/understanding-the-promise-type) we know that the `promise_type` member defines the type of the **Promise** object that is created within the coroutine frame and that controls the behaviour of the coroutine.

First, we need to implement the `get_return_object()` to construct the `task` object to return when the coroutine is invoked. This method just needs to initialise the task with the `std::coroutine_handle` of the newly create coroutine frame.

We can use the `std::coroutine_handle::from_promise()` method to manufacture one of these handles from the promise object.

> 从[上一篇](https://lewissbaker.github.io/2018/09/05/understanding-the-promise-type)中我们知道，`promise_type`成员定义了在协程帧中创建的**Promise**对象的类型，该对象控制着协程的行为。
>
> 首先，我们需要实现 `get_return_object()` 来构造 `task` 对象，以便在调用协程时返回。这个方法只需要用新创建的协程帧的 `std::coroutine_handle` 来初始化任务。
>
> 我们可以使用 `std::coroutine_handle::from_promise()` 方法从 promise 对象中创建一个这样的句柄。

```C++
class task::promise_type {
public:
  task get_return_object() noexcept {
    return task{std::coroutine_handle<promise_type>::from_promise(*this)};
  }
```

Next, we want the coroutine to initially suspend at the open curly brace so that we can later resume the coroutine from this point when the returned `task` is awaited.

There are several benefits of starting the coroutine lazily:

> 接下来，我们希望协程最初在打开的大括号处暂停，以便以后在等待返回的 `task` 时可以从此处继续协程。
>
> 延迟启动协程有几个好处：

1. It means that we can attach the continuation’s `std::coroutine_handle` before  starting execution of the coroutine. This means we don’t need to use  thread-synchronisation to arbitrate the race between attaching the  continuation later and the coroutine running to completion.
2. It means that the `task` destructor can unconditionally destroy the  coroutine frame - we don’t need to worry about whether the coroutine  is potentially executing on another thread since the coroutine will  not start executing until we await it, and while it is executing the  calling coroutine is suspended and so won’t attempt to call the task  destructor until the coroutine finishes executing.  This gives the compiler a much better chance at inlining the allocation  of the coroutine frame into the frame of the caller.  See [P0981R0](https://wg21.link/P0981R0) to read more about the Heap Allocation eLision Optimisation (HALO).
3. It also improves the exception-safety of your coroutine code. If you don’t  immediately `co_await` the returned `task` and do something else that  can throw an exception that causes the stack to unwind and the `task` destructor  to run then we can safely destroy the coroutine since we know it hasn’t  started yet. We aren’t left with the difficult choice between detaching,  potentially leaving dangling references, blocking in the destructor, terminating  or undefined-behaviour.  This is something that I cover in a bit more detail in my  [CppCon 2019 talk on Structured Concurrency](https://www.youtube.com/watch?v=1Wy5sq3s2rg).

> 1. 这意味着我们可以在开始执行协程之前附加继体的 `std::coroutine_handle`。这意味着我们不需要使用线程同步来决定稍后附加继体和协程运行完成之间的竞赛。
> 2. 这意味着 `task`析构函数可以无条件地销毁协程帧：我们无需担心协程是否可能在另一个线程上执行，因为在我们等待它之前，协程不会开始执行，而在它执行期间，调用的协程是暂停的，因此在协程执行完毕之前，不会尝试调用任务析构函数。 这样，编译器就更有机会将协程帧的分配内联到调用者的帧中。 请参见 [P0981R0](https://wg21.link/P0981R0)，了解有关堆分配优化（HALO）的更多信息。
> 3. 它还能提高协程代码的异常安全性。如果你没有立即 `await`返回的 `task`，而是做了其他可能抛出异常的事情，导致堆栈开解和 `task`析构函数运行，那么我们就可以安全地销毁协程，因为我们知道它还没有启动。这样，我们就不会在分离、可能留下悬空引用、在析构函数中阻塞、终止或未定义行为之间做出艰难的选择。 我在 [CppCon 2019 关于结构化并发的演讲](https://www.youtube.com/watch?v=1Wy5sq3s2rg) 中会更详细地介绍这一点。

To have the coroutine initially suspend at the open curly brace we define an `initial_suspend()` method that returns the builtin `suspend_always` type.

> 为了让协程在打开的大括号处初始暂停，我们定义了一个 `initial_suspend()` 方法，该方法返回内置的 `suspend_always` 类型。

```C++
  std::suspend_always initial_suspend() noexcept {
    return {};
  }
```

Next, we need to define the `return_void()` method, called when you execute `co_return;` or when execution runs off the end of the coroutine. This method doesn’t actually need to do anything, it just needs to exist so that the compiler knows that `co_return;` is valid within this coroutine type.

> 接下来，我们需要定义 `return_void()` 方法，它在执行 `co_return;` 或执行到协程结束时被调用。这个方法实际上不需要做任何事情，它的存在只是为了让编译器知道 `co_return;` 在这个协程类型中是有效的。

```C++
  void return_void() noexcept {}
```

We also need to add an `unhandled_exception()` method that is called if an exception escapes the body of the coroutine. For our purposes we can just treat the task coroutine bodies as `noexcept` and call `std::terminate()` if this happens.

> 我们还需要添加一个 `unhandled_exception()` 方法，当异常从协程主体中逃脱时，该方法将被调用。就我们的目的而言，我们可以将任务协程的主体视为 `noexcept` 并在发生这种情况时调用 `std::termininate()`。

```C++
  void unhandled_exception() noexcept {
    std::terminate();
  }
```

Finally, when the coroutine execution reaches the closing curly brace, we want the coroutine to suspend at the final-suspend point and then resume its continuation. ie. the coroutine that is awaiting the completion of this coroutine.

To support this, we need a data-member in the promise to hold the `std::coroutine_handle` of the continuation. We also need to define the `final_suspend()` method that returns an awaitable object that will resume the continuation after the current coroutine has suspended at the final-suspend point.

It’s important to delay resuming the continuation until after the current coroutine has suspended because the continuation may go on to immediately call the `task` destructor which will call `.destroy()` on the coroutine frame. The `.destroy()` method is only valid to call on a suspended coroutine and so it would be undefined-behaviour to resume the continuation before the current coroutine has suspended.

The compiler inserts code to evaluate the statement `co_await promise.final_suspend();` at the closing curly brace.

It’s important to note that the coroutine is not yet in a suspended state when the `final_suspend()` method is invoked. We need to wait until the `await_suspend()` method on the returned awaitable is called before the coroutine is suspended.

> 最后，当协程执行到结尾大括号处时，我们希望协程在最后暂停点暂停，然后恢复其继体，即等待此协程完成的协程。
>
> 为了支持这一点，我们需要在 promise 中添加一个数据成员来保存继体的 `std::coroutine_handle` 数据。我们还需要定义 `final_suspend()` 方法，该方法会返回一个 awaitable 对象，它将在当前协程暂停到 final-suspend 点后恢复继体。
>
> 将继体执行延迟到当前协程暂停后恢复是很重要的，因为继续执行可能会立即调用 `task` 析构函数，该函数将在协程帧上调用 `.destroy()`。`destroy()` 方法只能在暂停的协程上调用，因此在当前协程暂停之前恢复继续执行将是未定义的行为。
>
> 编译器会在结尾大括号处插入代码来评估语句 `co_await promise.final_suspend();`。
>
> 需要注意的是，调用 `final_suspend()` 方法时，协程尚未处于暂停状态。我们需要等到返回的 awaitable 上的 `await_suspend()` 方法被调用后，协程才会暂停。

```C++
  struct final_awaiter {
    bool await_ready() noexcept {
      return false;
    }

    void await_suspend(std::coroutine_handle<promise_type> h) noexcept {
      // The coroutine is now suspended at the final-suspend point.
      // Lookup its continuation in the promise and resume it.
      h.promise().continuation.resume();
    }

    void await_resume() noexcept {}
  };

  final_awaiter final_suspend() noexcept {
    return {};
  }

  std::coroutine_handle<> continuation;
};
```

Ok, so that’s the complete `promise_type`. The final piece we need to implement is the `task::operator co_await()`.

> 好了，这就是完整的 `promise_type`。我们需要实现的最后一部分是 `task::operator co_await()`。

## Implementing `task::operator co_await()`

You may remember from the [Understanding operator co_await() post](https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await) that when evaluating a `co_await` expression, the compiler will generate a call to `operator co_await()`, if one is defined, and then the object returned must have the `await_ready()`, `await_suspend()` and `await_resume()` methods defined.

When a coroutine awaits a `task` we want the awaiting coroutine to always suspend and then, once it has suspended, store the awaiting coroutine’s handle in the promise of the coroutine we are about to resume and then call `.resume()` on the `task`’s `std::coroutine_handle` to start executing the task.

Thus the relatively straight forward code:

> 你可能还记得在[理解 operator co_await()](https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await)一文中，编译器在求值 `co_await `表达式时，如果定义了 `operator co_await()`，编译器就会调用  `operator co_await()`，然后返回的对象必须定义了 `await_ready()`、`await_suspend() `和 `await_resume() `方法。
>
> 当一个协程等待一个`task`时，我们希望等待的协程总是暂停，一旦暂停，就将等待的协程句柄存储在我们要恢复的协程的 promise 中，然后在`task`的`std::coroutine_handle`上调用`.resume()`来开始执行任务。
>
> 这就是相对简单的代码：

```C++
class task::awaiter {
public:
  bool await_ready() noexcept {
    return false;
  }

  void await_suspend(std::coroutine_handle<> continuation) noexcept {
    // Store the continuation in the task's promise so that the final_suspend()
    // knows to resume this coroutine when the task completes.
    coro_.promise().continuation = continuation;

    // Then we resume the task's coroutine, which is currently suspended
    // at the initial-suspend-point (ie. at the open curly brace).
    coro_.resume();
  }

  void await_resume() noexcept {}

private:
  explicit awaiter(std::coroutine_handle<task::promise_type> h) noexcept
  : coro_(h)
  {}

  std::coroutine_handle<task::promise_type> coro_;
};

task::awaiter task::operator co_await() && noexcept {
  return awaiter{coro_};
}
```

And thus completes the code necessary for a functional `task` type.

You can see the complete set of code in Compiler Explorer here: https://godbolt.org/z/-Kw6Nf

> 这样，功能性`task`类型所需的代码就完成了。
>
> 您可以在这里的编译器资源管理器中查看整套代码： https://godbolt.org/z/-Kw6Nf

## The stack-overflow problem

The limitation of this implementation arises, however, when you start writing loops within your coroutines and you `co_await` tasks that can potentially complete synchronously within the body of that loop.

> 然而，当你开始在协程中编写循环，并且你的 `co_await `任务有可能在该循环的主体中同步完成时，这种实现方式的局限性就出现了。

For example:

```C++
task completes_synchronously() {
  co_return;
}

task loop_synchronously(int count) {
  for (int i = 0; i < count; ++i) {
    co_await completes_synchronously();
  }
}
```

With the naive `task` implementation described above, the `loop_synchronously()` function will (probably) work fine when `count` is 10, 1000, or even 100’000. But there will be a value that you can pass that will eventually cause this coroutine to start crashing.

For example, see: https://godbolt.org/z/gy5Q8q which crashes when `count` is 1’000’000.

The reason that this is crashing is because of stack-overflow.

> 通过上述天真的 `task` 实现，当 `count` 为 10、1000 甚至 100'000 时，`loop_synchronously()` 函数（可能）会工作正常。但会有一个你可以传递的值最终会导致这个协程开始崩溃。
>
> 例如，请参见：https://godbolt.org/z/gy5Q8q，当 `count` 为 1'000'000 时会崩溃。
>
> 崩溃的原因是堆栈溢出。

To understand why this code is causing a stack-overflow we need to take a look at what is happening when this code is executing. In particular, what is happening to the stack-frames.

When the `loop_synchronously()` coroutine first starts executing it will be because some other coroutine `co_await`ed the `task` returned. This will in turn suspend the awaiting coroutine and call `task::awaiter::await_suspend()` which will call `resume()` on the task’s `std::coroutine_handle`.

Thus the stack will look something like this when `loop_synchronously()` starts:

> 要理解这段代码为什么会导致堆栈溢出，我们需要看看这段代码执行时发生了什么。尤其是栈帧发生了什么变化。
>
> 当 `loop_synchronously()` 协程第一次开始执行时，是因为其他协程`co_await`了返回的`task`。这反过来会暂停正在等待的协程，并调用`task::awaiter::await_suspend()`，后者将在任务的`std::coroutine_handle`上调用`resume()`。
>
> 因此，当 `loop_synchronously()` 启动时，堆栈将如下所示：

```
           Stack                                                   Heap
+------------------------------+  <-- top of stack   +--------------------------+
| loop_synchronously$resume    | active coroutine -> | loop_synchronously frame |
+------------------------------+                     | +----------------------+ |
| coroutine_handle::resume     |                     | | task::promise        | |
+------------------------------+                     | | - continuation --.   | |
| task::awaiter::await_suspend |                     | +------------------|---+ |
+------------------------------+                     | ...                |     |
| awaiting_coroutine$resume    |                     +--------------------|-----+
+------------------------------+                                          V
|  ....                        |                     +--------------------------+
+------------------------------+                     | awaiting_coroutine frame |
                                                     |                          |
                                                     +--------------------------+
```

> Note: When a coroutine function is compiled the compiler typically splits it into two parts:
>
> 1. the “ramp function” which deals with the construction of the coroutine frame, parameter copying, promise construction and producing the return-value, and
> 2. the “coroutine body” which contains the user-authored logic from the body of the coroutine.
>
> I use the `$resume` suffix to refer to the “coroutine body” part of the coroutine.
>
> A later blog post will go into more detail about this split.
>
> > 注：编译协程函数时，编译器通常会将其分成两部分：
> >
> > 1. "斜坡函数"（ramp function），处理协程帧的构建、参数复制、承诺构建和返回值的生成；以及
> > 2. "协程主体"，它包含用户从协程主体中编写的逻辑。
> >
> > 我使用`$resume`后缀来指代协程的 "协程主体 "部分。
> >
> > 稍后的博文将详细介绍这种拆分。

Then when `loop_synchronously()` awaits the `task` returned from `completes_synchronously()` the current coroutine is suspended and calls `task::awaiter::await_suspend()`. The `await_suspend()` method then calls `.resume()` on the coroutine handle corresponding to the `completes_synchronously()` coroutine.

This resumes the `completes_synchronously()` coroutine which then runs to completion synchronously and suspends at the final-suspend point. It then calls `task::promise::final_awaiter::await_suspend()` which calls `.resume()` on the coroutine handle corresponding to `loop_synchronously()`.

The net result of all of this is that if we look at the state of the program just after the `loop_synchronously()` coroutine is resumed and just before the temporary `task` returned by `completes_synchronously()` is destroyed at the semicolon then the stack/heap should look something like this:

> 然后，当 `loop_synchronously()` 等待从 `completes_synchronously()` 返回的 `task` 时，当前协程被暂停，并调用 `task::awaiter::await_suspend()`。然后，`await_suspend() `方法在与 `completes_synchronously() `协程对应的协程句柄上调用`.resume()`。
>
> 这将恢复 `completes_synchronously()` 协程，然后该协程同步运行至完成，并在最终暂停点暂停。然后，它调用 `task::promise::final_awaiter::await_suspend()` ，后者在与 `loop_synchronously()` 对应的协程句柄上调用 `.resume()`。
>
> 所有这一切的最终结果是，如果我们查看一下程序的状态，就在 `loop_synchronously()` 协程恢复之后，以及 `completes_synchronously()` 返回的临时 `task` 在分号处销毁之前，那么堆栈/堆应该是这样的：

```
           Stack                                                   Heap
+-------------------------------+ <-- top of stack
| loop_synchronously$resume     | active coroutine -.
+-------------------------------+                   |
| coroutine_handle::resume      |            .------'
+-------------------------------+            |
| final_awaiter::await_suspend  |            |
+-------------------------------+            |  +--------------------------+ <-.
| completes_synchronously$resume|            |  | completes_synchronously  |   |
+-------------------------------+            |  | frame                    |   |
| coroutine_handle::resume      |            |  +--------------------------+   |
+-------------------------------+            '---.                             |
| task::awaiter::await_suspend  |                V                             |
+-------------------------------+ <-- prev top  +--------------------------+   |
| loop_synchronously$resume     |     of stack  | loop_synchronously frame |   |
+-------------------------------+               | +----------------------+ |   |
| coroutine_handle::resume      |               | | task::promise        | |   |
+-------------------------------+               | | - continuation --.   | |   |
| task::awaiter::await_suspend  |               | +------------------|---+ |   |
+-------------------------------+               | - task temporary --|---------'
| awaiting_coroutine$resume     |               +--------------------|-----+
+-------------------------------+                                    V
|  ....                         |               +--------------------------+
+-------------------------------+               | awaiting_coroutine frame |
                                                |                          |
                                                +--------------------------+
```

Then the next thing this will do is call the `task` destructor which will destroy the `completes_synchronously()` frame. It will then increment the `count` variable and go around the loop again, creating a new `completes_synchronously()` frame and resuming it.

In effect, what is happening here is that `loop_synchronously()` and `completes_synchronously()` end up recursively calling each other. Each time this happens we end up consuming a bit more stack-space, until eventually, after enough iterations, we overflow the stack and end up in undefined-behaviour land, typically resulting in your program promptly crashing.

Writing loops in coroutines built this way makes it very easy to write functions that perform unbounded recursion without looking like they are doing any recursion.

So, what would the solution look like under the original Coroutines TS design?

> 接下来，它会调用 `task` 析构函数来销毁 `completes_synchronously()` 帧。然后，它将递增 `count` 变量，并再次循环，创建一个新的 `completes_synchronously()` 框架并继续循环。
>
> 实际上，这里发生的事情是 `loop_synchronously()` 和 `completes_synchronously()` 最终会相互递归调用。每发生一次这样的情况，我们就会消耗更多的堆栈空间，直到最后，在足够多的迭代之后，我们会溢出堆栈，最终陷入未定义行为的境地，通常会导致程序立即崩溃。
>
> 以这种方式在协程中编写循环，可以很容易地编写出执行无限制递归的函数，而看起来却不像是在执行任何递归。
>
> 那么，在最初的 Coroutines TS 设计下，解决方案会是什么样的呢？

## The Coroutines TS solution

Ok, so what can we do about this to avoid this kind of unbounded recursion?

With the above implementation we are using the variant of `await_suspend()` that returns `void`. In the Coroutines TS there is also a version of `await_suspend()` that returns `bool` - if it returns `true` then the coroutine is suspended and execution returns to the caller of `resume()`, otherwise if it returns `false` then the coroutine is immediately resumed, but this time without consuming any additional stack-space.

So, to avoid the unbounded mutual recursion what we want to do is make use of the `bool`-returning version of `await_suspend()` to resume the current coroutine by returning `false` from the `task::awaiter::await_suspend()` method if the task completes synchronously instead of resuming the coroutine recursively using `std::coroutine_handle::resume()`.

> 好吧，那么我们该如何避免这种无限制递归呢？
>
> 在上述实现中，我们使用了返回 `void` 的 `await_suspend()` 变体。在协程 TS 中，`await_suspend()` 也有一个返回 `bool` 的版本--如果返回 `true`，则协程暂停，执行返回给 `resume()` 的调用者，否则，如果返回 `false`，则协程立即恢复，但这次不消耗任何额外的堆栈空间。
>
> 因此，为了避免无限制的相互递归，我们要做的是使用返回`bool`的`await_suspend()`版本，如果任务同步完成，则从`task::awaiter::await_suspend()`方法返回`false`来恢复当前协程，而不是使用`std::coroutine_handle::resume()`来递归恢复协程。

To implement a general solution for this there are two parts.

1. Inside the `task::awaiter::await_suspend()` method you can start executing the coroutine by calling `.resume()`. Then when the call to `.resume()` returns, check whether the coroutine has run to completion or not. If it has run to completion then we can return `false`, which indicates the awaiting coroutine should immediately resume, or we can return `true`, indicating that execution should return to the caller of `std::coroutine_handle::resume()`.
2. Inside `task::promise_type::final_awaiter::await_suspend()`, which is run when the coroutine runs to completion, we need to check whether the awaiting coroutine has (or will) return `true` from `task::awaiter::await_suspend()` and if so then resume it by calling `.resume()`. Otherwise, we need to avoid resuming the coroutine and notify `task::awaiter::await_suspend()` that it needs to return `false`.

> 要实现这个问题的一般解决方案，需要两个部分。
>
> 1. 在 `task::awaiter::await_suspend()` 方法内部，您可以通过调用 `.resume()` 开始执行协程。然后，当调用`.resume()`返回时，检查协程是否运行完成。如果已经运行完成，那么我们可以返回 `false`，表示等待中的协程应立即恢复，或者返回 `true`，表示执行应返回给 `std::coroutine_handle::resume()` 的调用者。
> 2. 在当协程运行完成时运行的 `task::promise_type::final_awaiter::await_suspend()` 内，我们需要检查等待中的协程是否已经（或将要）从 `task::awaiter::await_suspend()` 返回 `true`，如果是，则通过调用 `.resume()` 来恢复它。否则，我们需要避免恢复协程，并通知 `task::awaiter::await_suspend()` 它需要返回 `false`。

There is an added complication, however, in that it’s possible for a coroutine to start executing on the current thread then suspend and later resume and run to completion on a different thread before the call to `.resume()` returns. Thus, we need to be able to resolve the potential race between part 1 and part 2 above happening concurrently.

We will need to use a `std::atomic` value to decide the winner of the race here.

Now for the code. We can make the following modifications:

> 不过，还有一个额外的复杂因素，那就是协程有可能在当前线程上开始执行，然后暂停，然后在调用`.resume()`返回之前在另一个线程上恢复并运行完成。因此，我们需要解决上述第 1 部分和第 2 部分同时执行时可能出现的数据竞争问题。
>
> 我们需要使用 `std::atomic` 值来决定竞赛的胜负。
>
> 现在来看代码。我们可以做如下修改：

```C++
class task::promise_type {
  ...

  std::coroutine_handle<> continuation;
  std::atomic<bool> ready = false;
};

bool task::awaiter::await_suspend(std::coroutine_handle<> continuation) noexcept {
  promise_type& promise = coro_.promise();
  promise.continuation = continuation;
  coro_.resume();
  return !promise.ready.exchange(true, std::memory_order_acq_rel);
}

void task::promise_type::final_awaiter::await_suspend(std::coroutine_handle<promise_type> h) noexcept {
  promise_type& promise = h.promise();
  if (promise.ready.exchange(true, std::memory_order_acq_rel)) {
    // The coroutine did not complete synchronously, resume it here.
    promise.continuation.resume();
  }
}
```

See the updated example on Compiler Explorer: https://godbolt.org/z/7fm8Za Note how it no longer crashes when executing the `count == 1'000'000` case.

This turns out to be the approach that the `cppcoro::task<T>` [implementation](https://github.com/lewissbaker/cppcoro/blob/master/include/cppcoro/task.hpp) took to avoid the unbounded recursion problem (and still does for some platforms) and it has worked reasonably well.

Woohoo! Problem solved, right? Ship it! Right…?

> 请参阅编译器资源管理器上的更新示例：https://godbolt.org/z/7fm8Za 注意在执行 `count == 1'000'000` 情况时不再崩溃。
>
> 这就是 `cppcoro::task<T>` [实现](https://github.com/lewissbaker/cppcoro/blob/master/include/cppcoro/task.hpp) 为避免无限制递归问题而采取的方法（在某些平台上仍然如此），而且效果相当不错。
>
> 哇哦！问题解决了，对吧？可以发布了！对吧......？

## The problems

While the above solution does solve the recursion problem it has a couple of drawbacks.

Firstly, it introduces the need for `std::atomic` operations which can be quite costly. There is an atomic exchange on the caller when suspending the awaiting coroutine, and another atomic exchange on the callee when it runs to completion. If your application only ever executes on a single thread then you are paying the cost of the atomic operations for synchronising threads even though it’s never needed.

Secondly, it introduces additional branches. One in the caller, which needs to decide whether to suspend or immediately resume the coroutine, and one in the callee, which needs to decide whether to resume the continuation or suspend.

> 虽然上述解决方案确实解决了递归问题，但它也有几个缺点。
>
> 首先，它引入了对 `std::atomic `操作的需求，这种操作的代价可能相当高。在暂停等待协程时，调用者需要进行一次原子交换，而在运行完成时，被调用者需要进行另一次原子交换。如果您的应用程序只在单线程上执行，那么您就得为同步线程的原子操作付出代价，尽管这根本不需要。
>
> 其次，它引入了额外的分支。一个在调用方，它需要决定是暂停还是立即恢复协程，一个在被调用方，它需要决定是恢复继续还是暂停。

Note that the cost of this extra branch, and possibly even the atomic operations, would often be dwarfed by the cost of the business logic present in the coroutine. However, coroutines have been advertised as a zero cost abstraction and there have even been people using coroutines to suspend execution of a function to avoid waiting for an L1-cache-miss (see Gor’s great [CppCon talk on nanocoroutines](https://www.youtube.com/watch?v=j9tlJAqMV7U) for more details on this).

Thirdly, and probably most importantly, it introduces some non-determinism in the execution-context that the awaiting coroutine resumes on.

Let’s say I have the following code:

> 需要注意的是，与协程中业务逻辑的成本相比，这个额外分支的成本，甚至可能是原子操作的成本往往相形见绌。不过，协程一直被宣传为零成本的抽象，甚至有人使用协程来暂停函数的执行，以避免等待 L1 缓存错误（更多详情请参见 Gor 的精彩演讲[CppCon talk on nanocoroutines](https://www.youtube.com/watch?v=j9tlJAqMV7U)）。
>
> 第三，可能也是最重要的一点，它在等待协程恢复的执行上下文中引入了一些非确定性。
>
> 假设我有如下代码：

```C++
cppcoro::static_thread_pool tp;

task foo()
{
  std::cout << "foo1 " << std::this_thread::get_id() << "\n";
  // Suspend coroutine and reschedule onto thread-pool thread.
  co_await tp.schedule();
  std::cout << "foo2 " << std::this_thread::get_id() << "\n";
}

task bar()
{
  std::cout << "bar1 " << std::this_thread::get_id() << "\n";
  co_await foo();
  std::cout << "bar2" << std::this_thread::get_id() << "\n";
}
```

With the original implementation we were guaranteed that the code that runs after `co_await foo()` would run inline on the same thread that `foo()` completed on.

For example, one possible output would have been:

> 在最初的实现中，我们可以保证在 `co_await foo()` 之后运行的代码会在 `foo()` 完成的同一线程上内联运行。
>
> 例如，一个可能的输出结果是

```
bar1 1234
foo1 1234
foo2 3456
bar2 3456
```

However, with the changes to use atomics, it’s possible the completion of `foo()` may race with the suspension of `bar()` and this can, in some cases, mean that the code after `co_await foo()` might run on the original thread that `bar()` started executing on.

For example, the following output might now also be possible:

> 不过，由于改为使用原子，`foo()` 的完成可能会与`bar()` 的暂停发生竞赛，在某些情况下，这可能意味着`co_await foo()` 之后的代码可能会在`bar()` 开始执行的原始线程上运行。
>
> 例如，现在也可能出现以下输出：

```
bar1 1234
foo1 1234
foo2 3456
bar2 1234
```

For many use-cases this behaviour may not make a difference. However, for algorithms whose purpose is to transition execution context this can be problematic.

For example, the `via()` algorithm awaits some Awaitable and then produces it on the specified scheduler’s execution context. A simplified version of this algorithm is shown below.

> 对于许多用例来说，这种行为可能不会造成什么影响。然而，对于以转换执行上下文为目的的算法来说，这可能会造成问题。
>
> 例如，`via() `算法等待某个可等待对象，然后在指定调度程序的执行上下文中生成它。该算法的简化版本如下所示。

```C++
template<typename Awaitable, typename Scheduler>
task<await_result_t<Awaitable>> via(Awaitable a, Scheduler s)
{
  auto result = co_await std::move(a);
  co_await s.schedule();
  co_return result;
}

task<T> get_value();
void consume(const T&);

task<void> consumer(static_thread_pool::scheduler s)
{
  T result = co_await via(get_value(), s);
  consume(result);
}
```

With the original version the call to `consume()` is always guaranteed to be executed on the thread-pool, `s`. However, with the revised version that uses atomics it’s possible that `consume()` might either be executed on a thread associated with the scheduler, `s`, or on whatever thread the `consumer()` coroutine started execution on.

So how do we solve the stack-overflow problem without the overhead of the atomic operations, extra branches and the non-deterministic resumption context?

> 在原始版本中，对 `consume()` 的调用总是保证在线程池 `s` 中执行。然而，在使用原子的修订版中，`consume()` 有可能在与调度器关联的线程`s`上执行，或者在`consumer()` 协程开始执行的线程上执行。
>
> 那么，我们该如何解决堆栈溢出问题，而不产生原子操作、额外分支和非确定恢复上下文的开销呢？

## Enter “symmetric transfer”!

The paper [P0913R0](https://wg21.link/P0913R0) “Add symmetric coroutine control transfer” by Gor Nishanov (2018) proposed a solution to this problem by providing a facility which allows one coroutine to suspend and then resume another coroutine symmetrically without consuming any additional stack-space.

> 戈尔-尼尚诺夫（2018）的论文[P0913R0](https://wg21.link/P0913R0) "增加对称协程控制转移 "提出了解决这一问题的方法，即提供一种设施，允许一个协程对称地暂停然后恢复另一个协程，而不消耗任何额外的栈空间。

This paper proposed two key changes:

- Allow returning a `std::coroutine_handle<T>` from `await_suspend()` as a way of indicating that execution should be symmetrically transferred to the coroutine identified by the returned handle.
- Add a `std::experimental::noop_coroutine()` function that returns a special `std::coroutine_handle` that can be returned from `await_suspend()` to suspend the current coroutine and return from the call to `.resume()` instead of transferring execution to another coroutine.

> 本文提出了两项关键修改：
>
> - 允许从`await_suspend()`返回一个`std::coroutine_handle<T>`，以此表示执行应该对称地转移到返回的句柄所标识的协程。
> - 添加一个 `std::experimental::noop_coroutine()` 函数，返回一个特殊的 `std::coroutine_handle` 句柄，该句柄可以从 `await_suspend()` 返回，以暂停当前协程并从调用 `.resume()` 返回，而不是将执行转移到另一个协程。

So what do we mean by “symmetric transfer”?

When you resume a coroutine by calling `.resume()` on it’s `std::coroutine_handle` the caller of `.resume()` remains active on the stack while the resumed coroutine executes. When this coroutine next suspends and the call to `await_suspend()` for that suspend-point returns either `void` (indicating unconditional suspend) or `true` (indicating conditional suspend) then call to `.resume()` will return.

This can be thought of as an “asymmetric transfer” of execution to the coroutine and behaves just like an ordinary function call. The caller of `.resume()` can be any function (which may or may not be a coroutine). When that coroutine suspends and returns either `true` or `void` from `await_suspend()` then execution will return from the call to `.resume()` and

Every time we resume a coroutine by calling `.resume()` we create a new stack-frame for the execution of that coroutine.

> 那么 "对称传输 "是什么意思呢？
>
> 当你在一个协程的`std::coroutine_handle`上调用`.resume()`来恢复该协程时，当被恢复的协程执行时，`.resume()`的调用者仍在堆栈上处于活动状态。当该协程下一次暂停，并且针对该暂停点的 `await_suspend()` 调用返回 `void`（表示无条件暂停）或 `true`（表示有条件暂停）时，`.resume()` 的调用将返回。
>
> 这可以看作是向协程执行的 "非对称转移"，其行为与普通函数调用无异。`.resume()`的调用者可以是任何函数（可以是也可以不是协程）。当该协程暂停并从 `await_suspend()` 返回 `true` 或 `void` 时，执行将从对 `.resume()` 的调用返回，并且
>
> 每次通过调用 `.resume()` 来恢复协程时，我们都会为该协程的执行创建一个新的栈帧。

However, with “symmetric transfer” we are simply suspending one coroutine and resuming another coroutine. There is no implicit caller/callee relationship between the two coroutines - when a coroutine suspends it can transfer execution to any suspended coroutine (including itself) and does not necessarily have to transfer execution back to the previous coroutine when it next suspends or completes.

Let’s look at what the compiler lowers a `co_await` expression to when the awaiter makes use of symmetric-transfer:

> 然而，在 "对称转移 "中，我们只是暂停一个协程并恢复另一个协程。两个协程之间并不存在隐式的调用者/被调用者关系--当一个协程暂停时，它可以将执行转移到任何暂停的协程（包括它自己），而当它下一次暂停或完成时，并不一定要将执行转移回前一个协程。
>
> 让我们看看当等待者使用对称转移时，编译器会将 `co_await` 表达式降低到什么程度：

```C++
{
  decltype(auto) value = <expr>;
  decltype(auto) awaitable =
      get_awaitable(promise, static_cast<decltype(value)&&>(value));
  decltype(auto) awaiter =
      get_awaiter(static_cast<decltype(awaitable)&&>(awaitable));
  if (!awaiter.await_ready())
  {
    using handle_t = std::coroutine_handle<P>;

    //<suspend-coroutine>

    auto h = awaiter.await_suspend(handle_t::from_promise(p));
    h.resume();
    //<return-to-caller-or-resumer>
    
    //<resume-point>
  }

  return awaiter.await_resume();
}
```

Let’s zoom in on the key part that differs from other `co_await` forms:

> 让我们放大一下与其他 `co_await` 表单不同的关键部分：

```C++
auto h = awaiter.await_suspend(handle_t::from_promise(p));
h.resume();
//<return-to-caller-or-resumer>
```

Once the coroutine state-machine is lowered (a topic for another post), the `<return-to-caller-or-resumer>` part basically becomes a `return;` statement which causes the call to `.resume()` that last resumed the coroutine to return to its caller.

This means that we have the situation where we have a call to another function with the same signature, `std::coroutine_handle::resume()`, followed by a `return;` from the current function which is itself the body of a `std::coroutine_handle::resume()` call.

Some compilers, when optimisations are enabled, are able to apply an optimisation that turns calls to other functions the tail-position (ie. just before returning) into tail-calls as long as some conditions are met.

It just so happens that this kind of tail-call optimisation is exactly the kind of thing we want to be able to do to avoid the stack-overflow problem we were encountering before. But instead of being at the mercy of the optimiser as to whether or not the tail-call transformation is perfromed, we want to be able to guarantee that the tail-call transformation occurs, even when optimisations are not enabled.

But first let’s dig into what we mean by tail-calls.

> 一旦协程的状态机实现被转换为更低抽象层次上的表示（lowered）（这是另一篇文章的主题），`<return-to-caller-or-resumer>` 部分基本上就变成了`return;`语句，它会导致最后一次恢复协程的`.resume()`调用返回给它的调用者。
>
> 这就意味着，我们会调用另一个具有相同签名的函数 `std::coroutine_handle::resume()`，然后从当前函数调用 `return;`，而当前函数本身就是 `std::coroutine_handle::resume()`调用的主体。
>
> 有些编译器启用了优化功能，只要满足某些条件，就能将尾部位置（即返回前）对其他函数的调用转化为尾部调用。
>
> 恰好，这种尾调用优化正是我们希望能够避免之前遇到的堆栈溢出问题的。但是，我们并不想任由优化器决定是否完成尾调用转换，而是希望能够保证即使在未启用优化的情况下也能完成尾调用转换。
>
> 首先，让我们来了解一下尾调用的含义。

### Tail-calls

A tail-call is one where the current stack-frame is popped before the call and the current function’s return address becomes the return-address for the callee. ie. the callee will return directly the the caller of this function.

On X86/X64 architectures this generally means that the compiler will generate code that first pops the current stack-frame and then uses a `jmp` instruction to jump to the called function’s entry-point instead of using a `call` instruction and then popping the current stack-frame after the `call` returns.

This optimisation is generally only possible to do in limited circumstances, however.

> 尾调用是指在调用前弹出当前堆栈框架，当前函数的返回地址成为被调用者的返回地址，即被调用者将直接返回函数的调用者。
>
> 在 X86/X64 架构上，这通常意味着编译器生成的代码将首先弹出当前栈帧，然后使用 `jmp` 指令跳转到被调用函数的入口点，而不是使用 `call` 指令，然后在 `call` 返回后弹出当前栈帧。
>
> 不过，这种优化通常只能在有限的情况下进行。

In particular, it requires that:

- the calling convention supports tail-calls and is the same for the caller and callee;
- the return-type is the same;
- there are no non-trivial destructors that need to be run after the call before returning to the caller; and
- the call is not inside a try/catch block.

> - 它特别要求
>
>   - 调用约定支持尾调用，且调用方和被调用方的调用约定相同；
>   - 返回类型相同
>   - 在返回调用者之前，调用后没有需要运行的非平凡析构函数；
>   - 调用不在 try/catch 块内。

The shape of the symmetric-transfer form of `co_await` has actually been designed specifically to allow coroutines to satisfy all of these requirements. Let’s look at them individually.

**Calling convention** When the compiler lowers a coroutine into machine code it actually splits the coroutine up into two parts: the ramp (which allocates and initialises the coroutine frame) and the body (which contains the state-machine for the user-authored coroutine body).

The function signature of the coroutine (and thus any user-specified calling-convention) affects only the ramp part, whereas the body part is under the control of the compiler and is never directly called by any user-code - only by the ramp function and by `std::coroutine_handle::resume()`.

> 实际上，`co_await `的对称传输形式的形状就是为了让协程满足所有这些要求而专门设计的。让我们逐一来看。
>
> **调用约定** 当编译器将协程下放到机器码中时，它实际上将协程分成了两部分：过度部分（分配并初始化协程帧）和主体（包含用户编写的协程主体的状态机）。
>
> 协程的函数签名（以及任何用户指定的调用约定）只影响过度部分部分，而主体部分则由编译器控制，任何用户代码都不会直接调用，只有过度部分和 `std::coroutine_handle::resume()`会调用。

The calling-convention of the coroutine body part is not user-visible and is entirely up to the compiler and thus it can choose an appropriate calling convention that supports tail-calls and that is used by all coroutine bodies.

**Return type is the same** The return-type for both the source and target coroutine’s `.resume()` method is `void` so this requirement is trivially satisfied.

**No non-trivial destructors** When performing a tail-call we need to be able to free the current stack-frame before calling the target function and this requires the lifetime of all stack-allocated objects to have ended prior to the call.

Normally, this would be problematic as soon as there are any objects with non-trivial destructors in-scope as the lifetime of those objects would not yet have ended and those objects would have been allocated on the stack.

However, when a coroutine suspends it does so without exiting any scopes and the way it achieves this is by placing any objects whose lifetime spans a suspend-point in the coroutine frame rather than allocating them on the stack.

> 协程主体部分的调用约定用户无法看到，完全由编译器决定，因此编译器可以选择一个支持尾调用且所有协程主体都使用的适当调用约定。
>
> **返回类型相同**：源协程和目标协程的 `.resume()` 方法的返回类型都是 `void` ，因此这一要求可轻松满足。
>
> **没有非琐碎的析构函数** ：在执行尾调用时，我们需要在调用目标函数之前释放当前栈帧，这就要求所有栈分配对象的生命周期在调用之前已经结束。
>
> 通常情况下，只要范围内存在使用非琐析构函数的对象，这就会产生问题，因为这些对象的生命周期尚未结束，而且这些对象已经分配到栈中。
>
> 然而，当协程暂停时，它不会退出任何作用域，其实现方法是将生命周期跨越暂停点的对象置于协程帧中，而不是将其分配到堆栈中。

Local variables with lifetimes that do not span a suspend-point may be allocated on the stack, but the lifetime of these objects will have already ended and their destructors will have been called before the coroutine next suspends.

Thus there should be no non-trivial destructors for stack-allocated objects that need to be run after the return of the tail-call.

**Call not inside a try/catch block** This one is a little tricker as within every coroutine there is an implicit try/catch block that encloses the user-authored body of the coroutine.

> 生命周期不跨越暂停点的局部变量可以在堆栈上分配，但这些对象的生命周期已经结束，其析构函数也将在协程下一次暂停前被调用。
>
> 因此，在尾调用返回后，不应再运行堆栈分配对象的非琐析构函数。
>
> **不在 try/catch 块内调用** 这一点比较棘手，因为在每个协程中都有一个隐含的 try/catch 块，它将用户编写的协程主体包围起来。

From the specification, we see that the coroutine is defined as:

> 从说明书中，我们可以看到协程的定义如下：

```C++
{
  promise_type promise;
  co_await promise.initial_suspend();
  try { F; }
  catch (...) { promise.unhandled_exception(); }
final_suspend:
  co_await promise.final_suspend();
}
```

Where `F` is the user-authored part of the coroutine body.

Thus every user-authored `co_await` expression (other than initial/final_suspend) exists within the context of a try/catch block.

However, implementations work around this by actually executing the call to `.resume()` *outside* of the context of the try-block.

I hope to be able to go into this aspect in more detail in another blog post that goes into the details of the lowering of a coroutine to machine-code (this post is already long enough).

> 其中 `F` 是协程主体中用户自己写的部分。
>
> 因此，每个用户自创的 `co_await` 表达式（除 initial/final_suspend 之外）都存在于 try/catch 块的上下文中。
>
> 不过，实现方法是在 try 块的上下文之外实际执行对 `.resume()` 的调用，从而解决了这个问题。
>
> 我希望能在另一篇博文中更详细地介绍这方面的内容，这篇文章将详细介绍如何将协程转换为机器代码（这篇博文已经够长了）。

> Note, however, that the current wording in the C++ specification is not clear on requiring implementations to do this and it is only a non-normative note that hints that this is something that might be required. Hopefully we’ll be able to fix the specification in the future.
>
> > 但请注意，C++ 规范中目前的措辞并没有明确要求实现必须这样做，只是在非规范注释中暗示可能需要这样做。希望我们将来能修正该规范。

So we see that coroutines performing a symmetric-transfer generally satisfy all of the requirements for being able to perform a tail-call. The compiler guarantees that this will always be a tail-call, regardless of whether optimisations are enabled or not.

This means that by using the `std::coroutine_handle`-returning flavour of `await_suspend()` we can suspend the current coroutine and transfer execution to another coroutine without consuming extra stack-space.

This allows us to write coroutines that mutually and recursively resume each other to an arbitrary depth without fear of overflowing the stack.

> 因此我们可以看到，执行对称传输的协程一般都能满足执行尾调用的所有要求。编译器保证，无论是否启用优化，这都将是一次尾调用。
>
> 这意味着，通过使用 `std::coroutine_handle`-returning 方式的 `await_suspend()` 我们可以暂停当前协程，并将执行转移到另一个协程，而不会消耗额外的栈空间。
>
> 这样，我们就可以编写相互递归恢复到任意深度的协程，而不必担心堆栈溢出。

This is exactly what we need to fix our `task` implementation.

> 这正是我们需要解决的`task`实现问题。

## `task` revisited

So with the new “symmetric transfer” capability under our belt let’s go back and fix our `task` type implementation.

To do this we need to make changes to the two `await_suspend()` methods in our implementation:

- First so that when we await the task that we perform a symmetric-transfer to resume the task’s coroutine.
- Second so that when the task’s coroutine completes that it performs a symmetric transfer to resume the awaiting coroutine.

To address the await direction we need to change the `task::awaiter` method from this:

> 有了新的 "对称传输 "功能，让我们回过头来修正一下我们的 `task`类型实现。
>
> 为此，我们需要修改实现中的两个 `await_suspend()` 方法：
>
> - 首先，当我们等待任务时，我们要执行对称转移以恢复任务的协程。
> - 其次，当任务的协程完成时，执行对称转移以恢复等待的协程。
>
> 为了解决 await 方向的问题，我们需要修改 `task::awaiter` 方法，使其与下面的方法一致：

```C++
void task::awaiter::await_suspend(
    std::coroutine_handle<> continuation) noexcept {
  // Store the continuation in the task's promise so that the final_suspend()
  // knows to resume this coroutine when the task completes.
  coro_.promise().continuation = continuation;

  // Then we resume the task's coroutine, which is currently suspended
  // at the initial-suspend-point (ie. at the open curly brace).
  coro_.resume();
}
```

to this:

> 变成这样：

```C++
std::coroutine_handle<> task::awaiter::await_suspend(
    std::coroutine_handle<> continuation) noexcept {
  // Store the continuation in the task's promise so that the final_suspend()
  // knows to resume this coroutine when the task completes.
  coro_.promise().continuation = continuation;

  // Then we tail-resume the task's coroutine, which is currently suspended
  // at the initial-suspend-point (ie. at the open curly brace), by returning
  // its handle from await_suspend().
  return coro_;
}
```

And to address the return-path we need to update the `task::promise_type::final_awaiter` method from this:

> 为了解决返回路径问题，我们需要更新 `task::promise_type::final_awaiter` 方法：

```C++
void task::promise_type::final_awaiter::await_suspend(
    std::coroutine_handle<promise_type> h) noexcept {
  // The coroutine is now suspended at the final-suspend point.
  // Lookup its continuation in the promise and resume it.
  h.promise().continuation.resume();
}
```

to this:

> 变成这样：

```C++
std::coroutine_handle<> task::promise_type::final_awaiter::await_suspend(
    std::coroutine_handle<promise_type> h) noexcept {
  // The coroutine is now suspended at the final-suspend point.
  // Lookup its continuation in the promise and resume it symmetrically.
  return h.promise().continuation;
}
```

And now we have a `task` implementation that doesn’t suffer from the stack-overflow problem that the `void`-returning `await_suspend` flavour had and that doesn’t have the non-deterministic resumption context problem of the `bool`-returning `await_suspend` flavour had.

> 现在我们有了一个 `task` 实现，它不会像 `void` 返回的 `await_suspend` 版本那样出现堆栈溢出问题，也不会像 `bool` 返回的 `await_suspend` 版本那样出现非确定性恢复上下文问题。

### Visualising the stack

Let’s now go back and have a look at our original example:

> 现在让我们回过头来看看最初的例子：

```C++
task completes_synchronously() {
  co_return;
}

task loop_synchronously(int count) {
  for (int i = 0; i < count; ++i) {
    co_await completes_synchronously();
  }
}
```

When the `loop_synchronously()` coroutine first starts executing it will be because some other coroutine `co_await`ed the `task` returned. This will have been launched by symmetric transfer from some other coroutine, which would have been resumed by a call to `std::coroutine_handle::resume()`.

Thus the stack will look something like this when `loop_synchronously()` starts:

> 当 `loop_synchronously()` 协程第一次开始执行时，是因为其他协程`co_await`了返回的`task`。这将是通过其他协程的对称传输启动的，而其他协程将通过调用 `std::coroutine_handle::resume()`来恢复。
>
> 因此，当 `loop_synchronously()` 启动时，堆栈会是这样的：

```
           Stack                                                Heap
+---------------------------+  <-- top of stack   +--------------------------+
| loop_synchronously$resume | active coroutine -> | loop_synchronously frame |
+---------------------------+                     | +----------------------+ |
| coroutine_handle::resume  |                     | | task::promise        | |
+---------------------------+                     | | - continuation --.   | |
|     ...                   |                     | +------------------|---+ |
+---------------------------+                     | ...                |     |
                                                  +--------------------|-----+
                                                                       V
                                                  +--------------------------+
                                                  | awaiting_coroutine frame |
                                                  |                          |
                                                  +--------------------------+
```

Now, when it executes `co_await completes_synchronously()` it will perform a symmetric transfer to `completes_synchronously` coroutine.

> 现在，当执行 `co_await completes_synchronously()` 时，它将执行对称转移到 `completes_synchronously` 协程。

It does this by:

- calling the `task::operator co_await()` which then returns the `task::awaiter` object
- then suspends and calls `task::awaiter::await_suspend()` which then returns the `coroutine_handle` of the `completes_synchronously` coroutine.
- then performs a tail-call / jump to `completes_synchronously` coroutine. This pops the `loop_synchronously` frame before activing the `completes_synchronously` frame.

If we now look at the stack just after `completes_synchronously` is resumed it will now look like this:

> 它是通过以下方式实现的
>
> - 调用 `task::operator co_await()`，然后返回 `task::awaiter` 对象
> - 然后暂停并调用`task::awaiter::await_suspend()`，然后返回`completes_synchronously`协程的`coroutine_handle`。
> - 然后执行尾调用/跳转到 `completes_synchronously` 协程。这将在执行 `completes_synchronously` 帧之前弹出 `loop_synchronously` 帧。
>
> 如果我们现在查看 `completes_synchronously` 恢复后的堆栈，它现在看起来是这样的：

```
              Stack                                          Heap
                                            .-> +--------------------------+ <-.
                                            |   | completes_synchronously  |   |
                                            |   | frame                    |   |
                                            |   | +----------------------+ |   |
                                            |   | | task::promise        | |   |
                                            |   | | - continuation --.   | |   |
                                            |   | +------------------|---+ |   |
                                            `-, +--------------------|-----+   |
                                              |                      V         |
+-------------------------------+ <-- top of  | +--------------------------+   |
| completes_synchronously$resume|     stack   | | loop_synchronously frame |   |
+-------------------------------+ active -----' | +----------------------+ |   |
| coroutine_handle::resume      | coroutine     | | task::promise        | |   |
+-------------------------------+               | | - continuation --.   | |   |
|     ...                       |               | +------------------|---+ |   |
+-------------------------------+               | task temporary     |     |   |
                                                | - coro_       -----|---------`
                                                +--------------------|-----+
                                                                     V
                                                +--------------------------+
                                                | awaiting_coroutine frame |
                                                |                          |
                                                +--------------------------+
```

Note that the number of stack-frames has not grown here.

After the `completes_synchronously` coroutine completes and execution reaches the closing curly brace it will evaluate `co_await promise.final_suspend()`.

This will suspend the coroutine and call `final_awaiter::await_suspend()` which return the continuation’s `std::coroutine_handle` (ie. the handle that points to the `loop_synchronously` coroutine). This will then do a symmetric transfer/tail-call to resume the `loop_synchronously` coroutine.

If we look at the stack just after `loop_synchronously` is resumed then it will look something like this:

> 请注意，这里的堆栈帧数并没有增加。
>
> 在 `completes_synchronously` 协程完成并执行到结尾大括号后，它将评估 `co_await promise.final_suspend()`。
>
> 这将暂停协程，并调用 `final_awaiter::await_suspend()` 返回继续的 `std::coroutine_handle`（即指向 `loop_synchronously` 协程的句柄）。然后，它将进行对称转移/尾调用，以继续执行 "loop_synchronously "协程。
>
> 如果我们看一下刚恢复了 `loop_synchronously` 的堆栈，它看起来会是这样的：

```
           Stack                                                   Heap
                                                   +--------------------------+ <-.
                                                   | completes_synchronously  |   |
                                                   | frame                    |   |
                                                   | +----------------------+ |   |
                                                   | | task::promise        | |   |
                                                   | | - continuation --.   | |   |
                                                   | +------------------|---+ |   |
                                                   +--------------------|-----+   |
                                                                        V         |
+----------------------------+  <-- top of stack   +--------------------------+   |
| loop_synchronously$resume  | active coroutine -> | loop_synchronously frame |   |
+----------------------------+                     | +----------------------+ |   |
| coroutine_handle::resume() |                     | | task::promise        | |   |
+----------------------------+                     | | - continuation --.   | |   |
|     ...                    |                     | +------------------|---+ |   |
+----------------------------+                     | task temporary     |     |   |
                                                   | - coro_       -----|---------`
                                                   +--------------------|-----+
                                                                        V
                                                   +--------------------------+
                                                   | awaiting_coroutine frame |
                                                   |                          |
                                                   +--------------------------+
```

The first thing the `loop_synchronously` coroutine is going to do once resumed is to call the destructor of the temporary `task` that was returned from the call to `completes_synchronously` when execution reaches the semicolon. This will destroy the coroutine-frame, freeing its memory and leaving us with the following sitution:

> 当执行到分号处时，"completes_synchronously "协程恢复后要做的第一件事就是调用 "completes_synchronously "调用返回的临时 "task "的析构函数。这将销毁协程帧，释放其内存，并留下以下情况：

```
           Stack                                                   Heap
+---------------------------+  <-- top of stack   +--------------------------+
| loop_synchronously$resume | active coroutine -> | loop_synchronously frame |
+---------------------------+                     | +----------------------+ |
| coroutine_handle::resume  |                     | | task::promise        | |
+---------------------------+                     | | - continuation --.   | |
|     ...                   |                     | +------------------|---+ |
+---------------------------+                     | ...                |     |
                                                  +--------------------|-----+
                                                                       V
                                                  +--------------------------+
                                                  | awaiting_coroutine frame |
                                                  |                          |
                                                  +--------------------------+
```

We are now back to executing the `loop_synchronously` coroutine and we now have the same number of stack-frames and coroutine-frames as we started, and will do so each time we go around the loop.

Thus we can perform as many iterations of the loop as we want and will only use a constant amount of storage space.

For a full example of the symmetric-transfer version of the `task` type see the following Compiler Explorer link: https://godbolt.org/z/9baieF.

> 现在我们又回到了执行 `loop_synchronously` 协程帧的状态，我们现在拥有的堆栈帧和协程帧的数量与开始时相同，并且每次循环时都会如此。
>
> 这样，我们就可以随心所欲地执行循环迭代，而且只需使用恒定的存储空间。
>
> 有关 "任务 "类型的对称传输版本的完整示例，请参阅以下编译器资源管理器链接：https://godbolt.org/z/9baieF。

## Symmetric Transfer as the Universal Form of await_suspend

Now that we see the power and importance of the symmetric-transfer form of the awaitable concept, I want to show you that this form is actually the universal form, which can theoretically replace the `void` and `bool`-returning forms of `await_suspend()`.

But first we need to look at the other piece that the [P0913R0](https://wg21.link/P0913R0) proposal added to the coroutines design: `std::noop_coroutine()`.

> 现在，我们看到了可等待概念的对称转移形式的力量和重要性，我想向大家展示的是，这种形式实际上是通用形式，理论上可以取代`await_suspend()`的`void`和`bool`返回形式。
>
> 但首先我们需要看看 [P0913R0](https://wg21.link/P0913R0) 提案为协程设计添加的另一块内容：`std::noop_coroutine()`。

### Terminating the recursion

With the symmetric-transfer form of coroutines, every time the coroutine suspends it symmetrically resumes another coroutine. This is great as long as you have another coroutine to resume, but sometimes we don’t have another coroutine to execute and just need to suspend and let execution return to the caller of `std::coroutine_handle::resume()`.

Both the `void`-returning and `bool`-returning flavours of `await_suspend()` allow a coroutine to suspend and return from `std::coroutine_handle::resume()`, so how do we do that with the symmetric-transfer flavour?

> 在对称转移形式的协程中，每次协程暂停都会对称地恢复另一个协程。只要你有另一个协程要恢复，这就很好，但有时我们没有另一个协程要执行，只需要暂停并让执行返回到 `std::coroutine_handle::resume()`的调用者。
>
> `await_suspend()的 `void `返回和 `bool `返回方式都允许协程暂停并从`std::coroutine_handle::resume()`返回，那么我们如何用对称传输方式来做到这一点呢？

The answer is by using the special builtin `std::coroutine_handle`, called the “noop coroutine handle” which is produced by the function `std::noop_coroutine()`.

The “noop coroutine handle” is named as such because its `.resume()` implementation is such that it just immediately returns. i.e. resuming the coroutine is a no-op. Typically its implementation contains a single `ret` instruction.

> 答案是使用特殊的内置`std::coroutine_handle`，称为 "noop 协程句柄"，由函数`std::noop_coroutine()`产生。
>
> 之所以命名为 "noop 协程句柄"，是因为其`.resume() `实现是立即返回的，也就是说，恢复协程是没有操作的。通常，它的实现包含一条 `ret` 指令。

If the `await_suspend()` method returns the `std::noop_coroutine()` handle then instead of transferring execution to the next coroutine, it transfers execution back to the caller of `std::coroutine_handle::resume()`.

> 如果 `await_suspend()` 方法返回了 `std::noop_coroutine()` 句柄，那么它不会将执行转移到下一个协程，而是会将执行转移回 `std::coroutine_handle::resume()` 的调用者。

### Representing the other flavours of `await_suspend()`

With this information in-hand we can now show how to represent the other flavours of `await_suspend()` using the symmetric-transfer form.

The `void`-returning form

> 有了这些信息，我们现在就可以展示如何使用对称传输形式来表示其他形式的 `await_suspend()` 。
>
> 返回 `void` 的形式

```C++
void my_awaiter::await_suspend(std::coroutine_handle<> h) {
  this->coro = h;
  enqueue(this);
}
```

can also be written using both the `bool`-returning form:

> 也可以使用 "bool "返回形式：

```C++
bool my_awaiter::await_suspend(std::coroutine_handle<> h) {
  this->coro = h;
  enqueue(this);
  return true;
}
```

and can be written using the symmetric-transfer form:

> 并可以用对称传递形式写出：

```C++
std::noop_coroutine_handle my_awaiter::await_suspend(
    std::coroutine_handle<> h) {
  this->coro = h;
  enqueue(this);
  return std::noop_coroutine();
}
```

The `bool`-returning form:

> 返回`bool`的形式：

```C++
bool my_awaiter::await_suspend(std::coroutine_handle<> h) {
  this->coro = h;
  if (try_start(this)) {
    // Operation will complete asynchronously.
    // Return true to transfer execution to caller of
    // coroutine_handle::resume().
    return true;
  }

  // Operation completed synchronously.
  // Return false to immediately resume the current coroutine.
  return false;
}
```

can also be written using the symmetric-transfer form:

> 也能写成对称转移形式：

```C++
std::coroutine_handle<> my_awaiter::await_suspend(std::coroutine_handle<> h) {
  this->coro = h;
  if (try_start(this)) {
    // Operation will complete asynchronously.
    // Return std::noop_coroutine() to transfer execution to caller of
    // coroutine_handle::resume().
    return std::noop_coroutine();
  }

  // Operation completed synchronously.
  // Return current coroutine's handle to immediately resume
  // the current coroutine.
  return h;
}
```

### Why have all three flavours?

So why do we still have the `void` and `bool`-returning flavours of `await_suspend()` when we have the symmetric-transfer flavour?

The reason is partly historical, partly pragmatic and partly performance.

The `void`-returning version could be entirely replaced by returning the `std::noop_coroutine_handle` type from `await_suspend()` as this would be an equivalent signal to the compiler that the coroutine is unconditionally transfering execution to the caller of `std::coroutine_handle::resume()`.

> 那么，既然我们已经有了对称传输的`await_suspend()`，为什么还要使用`void`和`bool`返回的`await_suspend()`呢？
>
> 部分原因是历史，部分原因是实用，部分原因是性能。
>
> 从`await_suspend()`返回`std::noop_coroutine_handle`类型可以完全取代`void`返回版本，因为这对编译器来说是一个等效的信号，即协程无条件地将执行转移给`std::coroutine_handle::resume()`的调用者。

That it was kept was, IMO, partly because it was already in-use prior to the introduction of symmetric-transfer and partly because the `void`-form results in less-code/less-typing for the unconditional suspend case.

The `bool`-returning version, however, can have a slight win in terms of optimisability in some cases compared to the symmetric-transfer form.

Consider the case where we have a `bool`-returning `await_suspend()` method that is defined in another translation unit. In this case the compiler can generate code in the awaiting coroutine that will suspend the current coroutine and then conditionally resume it after the call to `await_suspend()` returns by just executing the next piece of code. It knows exactly the piece of code to execute next if `await_suspend()` returns `false`.

> 在我看来，保留它的部分原因是在引入对称转移之前它已经在使用，另一部分原因是 `void `形式在无条件暂停的情况下会导致较少代码/较少类型。
>
> 然而，在某些情况下，返回 `bool` 的版本在可优化性方面比对称转移形式略胜一筹。
>
> 考虑这样一种情况：我们在另一个翻译单元中定义了一个 `bool` 返回的 `await_suspend()` 方法。在这种情况下，编译器可以在等待的协程中生成代码，暂停当前协程，然后在调用`await_suspend()`返回后有条件地恢复协程，只需执行下一段代码即可。如果`await_suspend()`返回`false`，编译器就能准确地知道下一段要执行的代码。

With the symmetric-transfer flavour we still need to represent the same outcomes; either return to the caller/resume or resume the current coroutine. Instead of returning `true` or `false` we need to return `std::noop_coroutine()` or the handle to the current coroutine. We can coerce both of these handles into a `std::coroutine_handle<void>` type and return it.

However, now, because the `await_suspend()` method is defined in another translation unit the compiler can’t see what coroutine the returned handle is referring to and so when it resumes the coroutine it now has to perform some more expensive indirect calls and possibly some branches to resume the coroutine, compared to a single branch for the `bool`-returning case.

> 有了对称传输的味道，我们仍然需要表示相同的结果：要么返回给调用者/恢复，要么恢复当前协程。我们需要返回 `std::noop_coroutine()` 或当前协程的句柄，而不是返回 `true` 或 `false`。我们可以将这两个句柄合并为 `std::coroutine_handle<void>` 类型并返回。
>
> 但现在，由于 `await_suspend()` 方法是在另一个翻译单元中定义的，编译器无法看到返回的句柄指的是哪个协程，因此当它恢复协程时，现在必须执行一些更昂贵的间接调用，还可能要执行一些分支才能恢复协程，而在返回 `bool` 的情况下只需执行一个分支。

Now, it’s possible that we might be able to get equivalent performance out of the symmetric transfer version one day. For example, we could write our code in such a way that `await_suspend()` is defined inline but calls a `bool`-returning method that is defined out-of-line and then conditionally returns the appropriate handle.

> 现在，我们有可能从对称传输版本中获得同等性能。例如，我们可以这样编写代码：将 `await_suspend()` 定义为内联，但调用一个定义为外联的 `bool` 返回方法，然后有条件地返回相应的句柄。

For example:

```C++
struct my_awaiter {
  bool await_ready();

  // Compilers should in-theory be able to optimise this to the same
  // as the bool-returning version, but currently don't do this optimisation.
  std::coroutine_handle<> await_suspend(std::coroutine_handle<> h) {
    if (try_start(h)) {
      return std::noop_coroutine();
    } else {
      return h;
    }
  }

  void await_resume();

private:
  // This method is defined out-of-line in a separate translation unit.
  bool try_start(std::coroutine_handle<> h);
}
```

However, current compilers (c. Clang 10) are not currently able to optimise this to as efficient code as the equivalent `bool`-returning version. Having said that, you’re probably not going to notice the difference unless you’re awaiting this in a really tight loop.

So, for now, the general rule is:

- If you need to unconditionally return to `.resume()` caller, use the `void`-returning flavour.
- If you need to conditionally return to `.resume()` caller or resume current coroutine use the `bool`-returning flavour.
- If you need to resume another coroutine use the symmetric-transfer flavour.

> 不过，目前的编译器（例如 Clang 10）还无法将其优化为与等效的 "bool "返回版本一样高效的代码。尽管如此，除非你在一个非常紧凑的循环中等待，否则你可能不会注意到其中的差别。
>
> 因此，目前的一般规则是
>
> - 如果需要无条件返回到 `.resume()` 调用者，请使用 `void` 返回版本。
> - 如果需要有条件地返回 `.resume()` 调用者或恢复当前协程，请使用 `bool` 返回方式。
> - 如果需要恢复另一个协程，请使用对称转移方式。

# Rounding out

The new symmetric transfer capability added to coroutines for C++20 makes it much easier to write coroutines that recursively resume each other without fear of running into stack-overflow. This capability is key to making efficient and safe async coroutine types, such as the `task` one presented here.

This ended up being a much longer than expected post on symmetric transfer. If you made it this far, then thanks for sticking with it! I hope you found it useful.

In the next post, I’ll dive into understanding how the compiler transforms a coroutine function into a state-machine.

> C++20 为协程添加了新的对称传输功能，这使得编写相互递归恢复的协程变得更加容易，而不必担心出现堆栈溢出。这种能力是制作高效、安全的异步协程类型的关键，比如这里介绍的 "task "类型。
>
> 这篇关于对称传输的文章比预想的要长很多。如果你能读到这里，感谢你的坚持！希望对你有用。
>
> 在下一篇文章中，我将深入了解编译器如何将协程函数转换为状态机。

# Thanks

Thanks to Eric Niebler and Corentin Jabot for providing feedback on drafts of this post.
