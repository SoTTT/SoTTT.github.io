---
layout: post
title: C++协程:理解co_await操作符(译)
---

# C++ Coroutines: Understanding operator co_await

In the previous post on [Coroutine Theory](https://lewissbaker.github.io/2017/09/25/coroutine-theory) I described the high-level differences between functions and coroutines but without going into any detail on syntax and semantics of coroutines as described by the C++ Coroutines TS ([N4680](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4680.pdf)).

The key new facility that the Coroutines TS adds to the C++ language is the ability to suspend a coroutine, allowing it to be later resumed. The mechanism the TS provides for doing this is via the new `co_await` operator.

Understanding how the `co_await` operator works can help to demystify the behaviour of coroutines and how they are suspended and resumed. In this post I will be explaining the mechanics of the `co_await` operator and introduce the related **Awaitable** and **Awaiter** type concepts.

But before I dive into `co_await` I want to give a brief overview of the Coroutines TS to provide some context.

> 在前一篇协程理论中，我描述了函数和协程在高层次上的差别，但是并未深入 C++协程技术预览中的协程语法和语义。
>
> 协程技术预览为 C++语言带来的新关键语言设施是暂停和在稍后恢复协程的能力，TS 通过`co_await`操作符为此提供了机制。
>
> 理解`co_await`如何工作能够帮助我们看清协程的行为，了解它们是怎么暂停和恢复的。在这篇文章中我将解释`co_await`的机制并介绍相关的可等待体（Awaitable）和等待者（Awaiter）类型概念。

## What does the Coroutines TS give us?

- Three new language keywords: `co_await`, `co_yield` and `co_return`

- Several new types in the `std::experimental`namespace:

  - `coroutine_handle<P>`

  - `coroutine_traits<Ts...>`

  - `suspend_always`

  - `suspend_never`

- A general mechanism that library writers can use to interact with coroutines and customise their behaviour.

- A language facility that makes writing asynchronous code a whole lot easier!

The facilities the C++ Coroutines TS provides in the language can be thought of as a _low-level assembly-language_ for coroutines. These facilities can be difficult to use directly in a safe way and are mainly intended to be used by library-writers to build higher-level abstractions that application developers can work with safely.

The plan is to deliver these new low-level facilities into an upcoming language standard (hopefully C++20) along with some accompanying higher-level types in the standard library that wrap these low-level building-blocks and make coroutines more accessible in a safe way for application developers.

> - 三个新关键字：`co_await`，`co_yield`和`co_return`
>
> - 预览命名空间中的几个新类型：
>
>   - `coroutine_handle<P>`
>
>   - `coroutine_traits<Ts...>`
>
>   - `suspend_always`
>
>   - `suspend_never`
>
> - 一种通用的、可以供库作者用于和协程交互的机制，并且可以定制协程的行为
> - 一种可以让编写异步代码变得更简单的语言设施
>
> C++协程技术预览所提供的设施可以认为是协程的低级汇编语言，这些设施很难直接、安全地使用，它们的主要目的是提供给库的作者，使库作者可以用写出供应用开发者使用的、安全的高层抽象。
>
> 计划是要在即将发布的语言标准中交付新的低层设施，在标准库中也有与之相伴的高层类型，这些类型是低层组成部分的包装，它们让协程对应用开发者来说在安全方面拥有更高的可用性。

## Compiler <-> Library interaction

Interestingly, the Coroutines TS does not actually define the semantics of a coroutine. It does not define how to produce the value returned to the caller. It does not define what to do with the return value passed to the `co_return` statement or how to handle an exception that propagates out of the coroutine. It does not define what thread the coroutine should be resumed on.

Instead, it specifies a general mechanism for library code to customise the behaviour of the coroutine by implementing types that conform to a specific interface. The compiler then generates code that calls methods on instances of types provided by the library. This approach is similar to the way that a library-writer can customise the behaviour of a range-based for-loop by defining the `begin()`/`end()` methods and an `iterator` type.

The fact that the Coroutines TS doesn’t prescribe any particular semantics to the mechanics of a coroutine makes it a powerful tool. It allows library writers to define many different kinds of coroutines, for all sorts of different purposes.

For example, you can define a coroutine that produces a single value asynchronously, or a coroutine that produces a sequence of values lazily, or a coroutine that simplifies control-flow for consuming `optional<T>` values by early-exiting if a `nullopt` value is encountered.

There are two kinds of interfaces that are defined by the coroutines TS: The **Promise** interface and the **Awaitable** interface.

The **Promise** interface specifies methods for customising the behaviour of the coroutine itself. The library-writer is able to customise what happens when the coroutine is called, what happens when the coroutine returns (either by normal means or via an unhandled exception) and customise the behaviour of any `co_await` or `co_yield` expression within the coroutine.

The **Awaitable** interface specifies methods that control the semantics of a `co_await` expression. When a value is `co_await`ed, the code is translated into a series of calls to methods on the awaitable object that allow it to specify: whether to suspend the current coroutine, execute some logic after it has suspended to schedule the coroutine for later resumption, and execute some logic after the coroutine resumes to produce the result of the `co_await` expression.

I’ll be covering details of the **Promise** interface in a future post, but for now let’s look at the **Awaitable** interface.

> 有趣的是，协程技术预览实际上没有定义协程的语义，它没有定义如何产生返回值，它没有定义如何处理传递给`co_return`语句的返回值，也没有定义如何处理从协程中抛出的异常。它没有定义协程该在哪个线程上恢复。
>
> 取而代之的是，它为库定制协程的行为提供了一个通用的机制，这是通过实现符合特定接口的类型来达成的。这个方法类似库作者通过定义首尾方法和迭代器类型来定制基于范围的循环的行为。
>
> 事实上协程技术预览不预先为协程规定特定的语义使得它成为有力的工具，它允许库作者为不同种类的目的定义不同的协程。
>
> 例如，你可以定义一个异步地产生单值地协程、惰性地产生一系列值的协程，或者是简化一个消费`optional<T>`类型变量的控制流，当值为`nullopt`时提前退出。
>
> 协程技术预览定义了两种类型，Promise 接口和 Awaitable 接口
>
> Promise 接口给出了用于定制协程自身行为的方法。库作者可以自定义当协程被调用时、返回时（通过一般的方法或通过未处理的异常）会发生什么，也可以定义当协程中出现`co_yield`和`co_await`语句时的具体行为。
>
> Awaitable 接口给出控制`co_await`表达式语义的方法。当一个值被`co_await`时，这代码就被翻译成一系列 Awaitable 对象的方法的调用，这些方法指定是否要暂停当前协程，是否在它暂停之后执行一些逻辑以为协程的恢复作调度，也可以在协程恢复后执行一些逻辑来产生`co_await`表达式的值。
>
> 我将在未来的一篇博文中包含 Promise 的详情，但现在，我们先来看看 Awaitable 接口。

## Awaiters and Awaitables: Explaining `operator co_await`

The `co_await` operator is a new unary operator that can be applied to a value. For example: `co_await someValue`.

The `co_await` operator can only be used within the context of a coroutine. This is somewhat of a tautology though, since any function body containing use of the `co_await` operator, by definition, will be compiled as a coroutine.

A type that supports the `co_await` operator is called an **Awaitable** type.

Note that whether or not the `co_await` operator can be applied to a type can depend on the context in which the `co_await` expression appears. The promise type used for a coroutine can alter the meaning of a `co_await` expression within the coroutine via its `await_transform` method (more on this later).

To be more specific where required I like to use the term **Normally Awaitable** to describe a type that supports the `co_await` operator in a coroutine context whose promise type does not have an `await_transform` member. And I like to use the term **Contextually Awaitable** to describe a type that only supports the `co_await` operator in the context of certain types of coroutines due to the presence of an `await_transform` method in the coroutine’s promise type. (I’m open to better suggestions for these names here…)

An **Awaiter** type is a type that implements the three special methods that are called as part of a `co_await` expression: `await_ready`, `await_suspend` and `await_resume`.

Note that I have shamelessly “borrowed” the term ‘Awaiter’ here from the C# `async` keyword’s mechanics that is implemented in terms of a `GetAwaiter()` method which returns an object with an interface that is eerily similar to the C++ concept of an **Awaiter**. See [this post](https://weblogs.asp.net/dixin/understanding-c-sharp-async-await-2-awaitable-awaiter-pattern) for more details on C# awaiters.

Note that a type can be both an **Awaitable** type and an **Awaiter** type.

When the compiler sees a `co_await <expr>` expression there are actually a number of possible things it could be translated to depending on the types involved.

> `co_await`是个新的一元表达式，它作用于一个值，例如：`co_await someValue`
>
> co_await 操作符可以在协程上下文中使用，这在某种程度上是同义反复，因为根据定义，任何包含 co_await 操作符的函数体都将被编译为一个 coroutine。
>
> 一个支持 co_await 操作符的类型是个 Awaitable 类型。
>
> 需要注意的是 co_await 是否能应用在某个类型上其实取决于它使用的上下文。一个用于协程的 promise 类型可以通过它的 await_transform 方法改变一个 co_await 表达式的语义（具体的稍后再说）；
>
> 更明确地说，需要地时候我会用通用可等待体（Normally Awaitable）这个术语来描述一个在没有 await_transform 成员的 promise 类型的协程上下文中支持 co_await 的类型。同样，我也使用术语上下文可等待体（Contextually Awaitable）来描述一个类型，由于在 coroutine 的 promise 类型中存在 await_transform 方法，它仅在某些类型的 coroutine 的上下文中支持 co_await 操作符（关于这些名称，我欢迎更好的建议......）；
>
> 一个 Awaiter 类型是一个实现了三个特定的方法的类型，所以可以用来充当 co_await 的目标，这三个方法是：`await_ready`，`await_suspend` 和 `await_resume`。
>
> 请注意，我在这里无耻地 "借用 "了 C# async 关键字机制中的 "Awaiter "一词，该机制是通过 GetAwaiter() 方法实现的，该方法返回一个具有与 C++ Awaiter 概念极为相似的接口的对象。有关 C# 等待者的更多详情，请参阅[本文章](https://weblogs.asp.net/dixin/understanding-c-sharp-async-await-2-awaitable-awaiter-pattern)。
>
> 需要注意的是一个类型可以同时是 Awaiter 和 Awaitable。
>
> 当编译器看见一个`co_await <expr>`表达式时，对于它会被翻译成什么其实有很多种可能，这取决于被调用的类型。

### Obtaining the Awaiter

The first thing the compiler does is generate code to obtain the **Awaiter** object for the awaited value. There are a number of steps to obtaining the awaiter object which are set out in N4680 section 5.3.8(3).

Let’s assume that the promise object for the awaiting coroutine has type, `P`, and that `promise` is an l-value reference to the promise object for the current coroutine.

If the promise type, `P`, has a member named `await_transform` then `<expr>` is first passed into a call to `promise.await_transform(<expr>)` to obtain the **Awaitable** value, `awaitable`. Otherwise, if the promise type does not have an `await_transform` member then we use the result of evaluating `<expr>` directly as the **Awaitable** object, `awaitable`.

Then, if the **Awaitable** object, `awaitable`, has an applicable `operator co_await()` overload then this is called to obtain the **Awaiter** object. Otherwise the object, `awaitable`, is used as the awaiter object.

If we were to encode these rules into the functions `get_awaitable()` and `get_awaiter()`, they might look something like this:

> 编译器做的第一件事情是为被等待的值获取一个 Awaiter 对象，N4680 的 5.3.8-3 章节列出了获取 Awaiter 对象的几个步骤。
>
> 我们先假定在等待的协程的 promise 对象是 P 类型的，且 promise 对象是个当前协程中的对象的左值引用。
>
> 如果这个 promise 类型 P 有个名叫`await_transform`的成员方法，那么`<expr>`会先被传递给`promise.await_transform(<expr>)`，目的是获取一个 Awaitable 对象；反之，若这个 promise 类型没有这样的一个成员方法，那就直接用这个表达式的值做 Awaitable 对象。
>
> 之后，如果这个 Awaitable 对象有个适当的`operator co_await()`重载，就要调用这个方法获取 Awaiter 对象，反之，就用这个对象作为 Awaiter 对象。
>
> 如果我们将这些规则编码成函数 `get_awaitable()` 和 `get_awaiter()`，它们可能看起来像这样：

```C++
template<typename P, typename T>
decltype(auto) get_awaitable(P& promise, T&& expr)
{
  if constexpr (has_any_await_transform_member_v<P>)
    return promise.await_transform(static_cast<T&&>(expr));
  else
    return static_cast<T&&>(expr);
}

template<typename Awaitable>
decltype(auto) get_awaiter(Awaitable&& awaitable)
{
  if constexpr (has_member_operator_co_await_v<Awaitable>)
    return static_cast<Awaitable&&>(awaitable).operator co_await();
  else if constexpr (has_non_member_operator_co_await_v<Awaitable&&>)
    return operator co_await(static_cast<Awaitable&&>(awaitable));
  else
    return static_cast<Awaitable&&>(awaitable);
}
```

### Awaiting the Awaiter

So, assuming we have encapsulated the logic for turning the `<expr>` result into an **Awaiter** object into the above functions then the semantics of `co_await <expr>` can be translated (roughly) as follows:

> 因此，假设我们已将把 `<expr> `结果转化为 Awaiter 对象的逻辑封装到上述函数中，那么 co_await `<expr>` 的语义可以（大致）翻译如下：

```C++
{
  auto&& value = <expr>;
  auto&& awaitable = get_awaitable(promise, static_cast<decltype(value)>(value));
  auto&& awaiter = get_awaiter(static_cast<decltype(awaitable)>(awaitable));
  if (!awaiter.await_ready())
  {
    using handle_t = std::experimental::coroutine_handle<P>;

    using await_suspend_result_t =
      decltype(awaiter.await_suspend(handle_t::from_promise(p)));

    <suspend-coroutine>

    if constexpr (std::is_void_v<await_suspend_result_t>)
    {
      awaiter.await_suspend(handle_t::from_promise(p));
      <return-to-caller-or-resumer>
    }
    else
    {
      static_assert(
         std::is_same_v<await_suspend_result_t, bool>,
         "await_suspend() must return 'void' or 'bool'.");

      if (awaiter.await_suspend(handle_t::from_promise(p)))
      {
        <return-to-caller-or-resumer>
      }
    }

    <resume-point>
  }

  return awaiter.await_resume();
}
```

The `void`-returning version of `await_suspend()` unconditionally transfers execution back to the caller/resumer of the coroutine when the call to `await_suspend()` returns, whereas the `bool`-returning version allows the awaiter object to conditionally resume the coroutine immediately without returning to the caller/resumer.

> 当使用了`void`返回值的版本的`await_suspend`返回时，它无条件的转回到协程的调用者或恢复者执行；相对地有`bool`返回值版本的那个版本的函数允许 awaiter 在一定的条件下直接恢复而不是返回到调用者或恢复者。

The `bool`-returning version of `await_suspend()` can be useful in cases where the awaiter might start an async operation that can sometimes complete synchronously. In the cases where it completes synchronously, the `await_suspend()` method can return `false` to indicate that the coroutine should be immediately resumed and continue execution.

> `await_suspend`的`void`返回值版本可以用在 awaiter 可能进行一个有时候可能会同步完成的异步操作的情况，在那种同步完成的情况下，`await_suspend`方法返回假值用以表明协程应该直接恢复并继续执行。

At the `<suspend-coroutine>` point the compiler generates some code to save the current state of the coroutine and prepare it for resumption. This includes storing the location of the `<resume-point>` as well as spilling any values currently held in registers into the coroutine frame memory.

> 在`<suspend-coroutine>`处编译器生成一些代码来保存协程当前的状态，为协程的恢复做准备；包括保存`<resume-point>`的位置，就像将保存在寄存器中的值保存到协程帧内存区域中。

The current coroutine is considered suspended after the `<suspend-coroutine>` operation completes. The first point at which you can observe the suspended coroutine is inside the call to `await_suspend()`. Once the coroutine is suspended it is then able to be resumed or destroyed.

> 这个协程在`<suspend-coroutine>`执行完成后可以认为认为是已经暂停了，我们能观察协程的首个位置是`await_suspend`调用的内部，在协程第一次暂停之后，它可以被恢复或者销毁。

It is the responsibility of the `await_suspend()` method to schedule the coroutine for resumption (or destruction) at some point in the future once the operation has completed. Note that returning `false` from `await_suspend()` counts as scheduling the coroutine for immediate resumption on the current thread.

> 在未来一个操作首次完成的时间点上，调度协程恢复或析构是`await_suspend`的责任。需要注意的是`await_suspend`返回`false`算作调度协程在当前线程上直接恢复。

The purpose of the `await_ready()` method is to allow you to avoid the cost of the `<suspend-coroutine>` operation in cases where it is known that the operation will complete synchronously without needing to suspend.

> `await_ready`方法的目的是让你在知道这个操作会同步完成而不需要暂停时规避`<suspend-coroutine>`操作的开销。

At the `<return-to-caller-or-resumer>` point execution is transferred back to the caller or resumer, popping the local stack frame but keeping the coroutine frame alive.

> 在`<return-to-caller-or-resumer>`处，执行转回到调用者或恢复者，然后弹出栈帧，但是协程帧保持有效。

When (or if) the suspended coroutine is eventually resumed then the execution resumes at the `<resume-point>`. ie. immediately before the `await_resume()` method is called to obtain the result of the operation.

> 如果一个已经暂停的协程最终恢复，那协程的执行会从`<resume-point>`处恢复，也就是用于产生操作的结果的`await_resume`函数调用前面的那个。

The return-value of the `await_resume()` method call becomes the result of the `co_await` expression. The `await_resume()` method can also throw an exception in which case the exception propagates out of the `co_await` expression.

> `await_resume()`的返回值会作为`co_await`表达式的结果，`await_resume()`方法中抛出的异常会从`co_await`表达式中传递出来。

Note that if an exception propagates out of the `await_suspend()` call then the coroutine is automatically resumed and the exception propagates out of the `co_await` expression without calling `await_resume()`.

> 要注意的是，如果异常从`await_suspend()`调用中传播出来，那协程会自动恢复并且将异常从`co_await`表达式中传播出来而不会调用`await_resume()`。

## Coroutine Handles

You may have noticed the use of the `coroutine_handle<P>` type that is passed to the `await_suspend()` call of a `co_await` expression.

This type represents a non-owning handle to the coroutine frame and can be used to resume execution of the coroutine or to destroy the coroutine frame. It can also be used to get access to the coroutine’s promise object.

The `coroutine_handle` type has the following (abbreviated) interface:

> 你可能注意到了`coroutine_handle<P>`类型的用法是传递给`co_await`表达式的`await_suspend()`调用
>
> 这个类型代表了一个指向协程帧的非独占的句柄，可以用来恢复协程或销毁协程帧。它也可以用来访问协程的 promise 对象。
>
> `coroutine_handle`类型有下述的接口（简略版）：

```
namespace std::experimental
{
  template<typename Promise>
  struct coroutine_handle;

  template<>
  struct coroutine_handle<void>
  {
    bool done() const;

    void resume();
    void destroy();

    void* address() const;
    static coroutine_handle from_address(void* address);
  };

  template<typename Promise>
  struct coroutine_handle : coroutine_handle<void>
  {
    Promise& promise() const;
    static coroutine_handle from_promise(Promise& promise);

    static coroutine_handle from_address(void* address);
  };
}
```

When implementing **Awaitable** types, they key method you’ll be using on `coroutine_handle` will be `.resume()`, which should be called when the operation has completed and you want to resume execution of the awaiting coroutine. Calling `.resume()` on a `coroutine_handle` reactivates a suspended coroutine at the `<resume-point>`. The call to `.resume()` will return when the coroutine next hits a `<return-to-caller-or-resumer>` point.

> 当要实现 Awaitable 类型时，我们要在`coroutine_handle`上使用的关键方法是`.resume()`，应该在操作已经完成且你想要让正在等待的协程恢复时调用它。在一个`coroutine_hendle`上调用`.resume()`将在`<resume-point>`处激活暂停的协程。这个调用会在协程遇到下一个`<return-to-caller-or-resumer>`时返回。

The `.destroy()` method destroys the coroutine frame, calling the destructors of any in-scope variables and freeing memory used by the coroutine frame. You should generally not need to (and indeed should really avoid) calling `.destroy()` unless you are a library writer implementing the coroutine promise type. Normally, coroutine frames will be owned by some kind of RAII type returned from the call to the coroutine. So calling `.destroy()` without cooperation with the RAII object could lead to a double-destruction bug.

> `.destroy()`方法销毁协程帧，调用作用域内的变量的析构函数并释放协程帧使用的内存，你通常不需要调用`.destory()`除非你是实现协程 promise 类型的库作者。一般来说，协程帧会被协程返回的 RAII 类型拥有，所以调用`destroy()`但不与 RAII 对象协作处理可能导致双重析构的问题。

The `.promise()` method returns a reference to the coroutine’s promise object. However, like `.destroy()`, it is generally only useful if you are authoring coroutine promise types. You should consider the coroutine’s promise object as an internal implementation detail of the coroutine. For most **Normally Awaitable** types you should use `coroutine_handle<void>` as the parameter type to the `await_suspend()` method instead of `coroutine_handle<Promise>`.

> `.promise()`方法返回对协程的 promise 对象的引用，但是，就像`destory()`，它一般只对 promise 类型的作者有用。你可以认为协程的 promise 类型是协程内部的具体实现。对于大多数 Normally Awaitable 类型，你应该使用`coroutine_handle<void>`作为传入给`await_suspend()`的参数类型而不是`coroutine_handle<Promise>`。

The `coroutine_handle<P>::from_promise(P& promise)` function allows reconstructing the coroutine handle from a reference to the coroutine’s promise object. Note that you must ensure that the type, `P`, exactly matches the concrete promise type used for the coroutine frame; attempting to construct a `coroutine_handle<Base>` when the concrete promise type is `Derived` can lead to undefined behaviour.

> `coroutine_handle<P>::from_promise(P& promise)`函数允许从协程的 promise 类型的引用重构，要注意你要确保 P 类型确实和协程帧是匹配的，试图在实际的 promise 类型是`Derived`时构造 `coroutine_handle<Base>`会导致未定义行为。

The `.address()` / `from_address()` functions allow converting a coroutine handle to/from a `void*` pointer. This is primarily intended to allow passing as a ‘context’ parameter into existing C-style APIs, so you might find it useful in implementing **Awaitable** types in some circumstances. However, in most cases I’ve found it necessary to pass additional information through to callbacks in this ‘context’ parameter so I generally end up storing the `coroutine_handle` in a struct and passing a pointer to the struct in the ‘context’ parameter rather than using the `.address()` return-value.

> `.address()` / `from_address()`函数允许将一个协程句柄在句柄对象和 `void*` 指针之间转换。允许将协程句柄作为上下文参数传入一个存在的 C 风格 API 中，所以你可能在一些环境下的 Awaitable 的实现中发现它的用处。但是，在大多数情况下我们发现在这个上下文中传递额外的信息给回调函数是必要的，所以最后，我们一般会把协程句柄保存在结构体中，并且将这个结构体的指针传递给上下文参数，而不是用`.address()`的返回值。

## Synchronisation-free async code

One of the powerful design-features of the `co_await` operator is the ability to execute code after the coroutine has been suspended but before execution is returned to the caller/resumer.

> `co_await`操作符重要的设计目的之一就是能够在协程已经暂停之后、调用者或恢复者返回之前运行代码。

This allows an Awaiter object to initiate an async operation after the coroutine is already suspended, passing the `coroutine_handle` of the suspended coroutine to the operation which it can safely resume when the operation completes (potentially on another thread) without any additional synchronisation required.

> 这允许一个 Awaiter 对象在协程已经暂停之后初始化一个异步操作，将暂停的协程的句柄传递给这个操作，它就可以在操作完成之后安全地被唤醒（潜在地在另一个线程上），而不需要额外地同步。

For example, by starting an async-read operation inside `await_suspend()` when the coroutine is already suspended means that we can just resume the coroutine when the operation completes without needing any thread-synchronisation to coordinate the thread that started the operation and the thread that completed the operation.

> 例如，通过在`await_suspend()`内开始一个异步读操作，这时协程已经暂停了；即使这样，我们仍然可以在操作完成时恢复协程，而不需要线程同步去协调开始操作地线程和操作完成地线程。

```
Time     Thread 1                           Thread 2
  |      --------                           --------
  |      ....                               Call OS - Wait for I/O event
  |      Call await_ready()                    |
  |      <supend-point>                        |
  |      Call await_suspend(handle)            |
  |        Store handle in operation           |
  V        Start AsyncFileRead ---+            V
                                  +----->   <AsyncFileRead Completion Event>
                                            Load coroutine_handle from operation
                                            Call handle.resume()
                                              <resume-point>
                                              Call to await_resume()
                                              execution continues....
           Call to AsyncFileRead returns
         Call to await_suspend() returns
         <return-to-caller/resumer>
```

One thing to be _very_ careful of when taking advantage of this approach is that as soon as you have started the operation which publishes the coroutine handle to other threads then another thread may resume the coroutine on another thread before `await_suspend()` returns and may continue executing concurrently with the rest of the `await_suspend()` method.

> 在发挥这个方案的优势时有件事情要注意，那就是一旦开始了操作，也就把协程句柄公开给了其他线程，其他线程可以在`await_suspend()`返回之前恢复了协程，协程就可能和`await_suspend()`方法的剩余部分并行。

The first thing the coroutine will do when it resumes is call `await_resume()` to get the result and then often it will immediately destruct the **Awaiter** object (ie. the `this` pointer of the `await_suspend()` call). The coroutine could then potentially run to completion, destructing the coroutine and promise object, all before `await_suspend()` returns.

> 在协程恢复时它要做的第一件事是调用`await_resume()`来获取结果，之后往往会直接析构 Awaiter 对象。协程之后潜在地运行到结束，析构这个协程和 promise 对象，在`await_suspend()`返回之前。

So within the `await_suspend()` method, once it’s possible for the coroutine to be resumed concurrently on another thread, you need to make sure that you avoid accessing `this` or the coroutine’s `.promise()` object because both could already be destroyed. In general, the only things that are safe to access after the operation is started and the coroutine is scheduled for resumption are local variables within `await_suspend()`.

> 所以在`await_suspend()`方法中，协程有第一次在另一个线程上并行恢复的机会，你需要确保你不会访问 this 指针或者协程的`.promise()`对象，因为它们已经被销毁了，一般地来说，操作开始和协程为了恢复而被调度之后仅有的可以安全地访问的东西就只有`await_suspend()`的局部变量了。

### Comparison to Stackful Coroutines

I want to take a quick detour to compare this ability of the Coroutines TS stackless coroutines to execute logic after the coroutine is suspended with some existing common stackful coroutine facilities such as Win32 fibers or boost::context.

> 在这里我想岔开一下话题来对比技术预览中的无栈协程和现有的一般的有栈协程设施在暂停之后的执行逻辑的能力，有栈协程的例子就像 Win32 中的纤程或者是 boost::context 那样。

With many of the stackful coroutine frameworks, the suspend operation of a coroutine is combined with the resumption of another coroutine into a ‘context-switch’ operation. With this ‘context-switch’ operation there is typically no opportunity to execute logic after suspending the current coroutine but before transferring execution to another coroutine.

> 对于很多有栈协程框架，协程的暂停和另一个协程的恢复是合并在一个上下文切换的操作中的。这个上下文切换的操作一般没有机会在协程暂停后但在另一个协程执行前执行逻辑。

This means that if we want to implement a similar async-file-read operation on top of stackful coroutines then we have to start the operation _before_ suspending the coroutine. It is therefore possible that the operation could complete on another thread before the coroutine is suspended and is eligible for resumption. This potential race between the operation completing on another thread and the coroutine suspending requires some kind of thread synchronisation to arbitrate and decide on the winner.

> 这个意思是如果我们想在正在运行的有栈协程上实现一个简单的异步文件读取操作，我们必须在协程暂停前开始操作，因此，操作可能在协程还没暂停之前就在另一个线程上完成了，这个线程就可以恢复了。操作在另一个线程上完成和协程的暂停构成一对潜在的竞争，需要某种线程同步来判断并决出胜者。

There are probably ways around this by using a trampoline context that can start the operation on behalf of the initiating context after the initiating context has been suspended. However this would require extra infrastructure and an extra context-switch to make it work and it’s possible that the overhead this introduces would be greater than the cost of the synchronisation it’s trying to avoid.

> 通过在初始化上下文已经暂停后使用一个能够在没有完全初始化上下文的情况下开始操作的弹性上下文是一个可行的回避措施。但是这需要额外的基础设施和额外的上下文切换来让它工作，而且它带来的开销可能比同步手段更大，而同步手段的开销正是这个方法试图避免的。

## Avoiding memory allocations

Async operations often need to store some per-operation state that keeps track of the progress of the operation. This state typically needs to last for the duration of the operation and should only be freed once the operation has completed.

> 异步操作通常需要保存一些预操作状态以追踪操作的进展。这些状态一般需要持续到操作的最后，而且仅应该在操作完成时被释放一次。

For example, calling async Win32 I/O functions requires you to allocate and pass a pointer to an `OVERLAPPED` structure. The caller is responsible for ensuring this pointer remains valid until the operation completes.

> 例如，调用异步的 Win32 IO 函数需要你分配并且传递一个指针给一个`OVERLAPPED`结构，调用者有责任保证这指针保持有效直达操作完成。

With traditional callback-based APIs this state would typically need to be allocated on the heap to ensure it has the appropriate lifetime. If you were performing many operations, you may need to allocate and free this state for each operation. If performance is an issue then a custom allocator may be used that allocates these state objects from a pool.

> 对于传统的、基于回调的 API 来说这个状态一般需要分配在堆上以确保它有合适的生命周期。如果你正在运行很多操作，你可能要为每一个操作都分配和释放状态。如果性能是个问题，可以使用自定义的分配器来从一个池中分配状态对象。

However, when we are using coroutines we can avoid the need to heap-allocate storage for the operation state by taking advantage of the fact that local variables within the coroutine frame will be kept alive while the coroutine is suspended.

> 但是，当我们在使用一个协程时，保存在协程帧中的局部变量会在协程暂停时保持有效，我们能够通过利用这个事实来规避使用堆分配来存储操作状态的需要。

By placing the per-operation state in the **Awaiter** object we can effectively “borrow” memory from the coroutine frame for storing the per-operation state for the duration of the `co_await` expression. Once the operation completes, the coroutine is resumed and the **Awaiter** object is destroyed, freeing that memory in the coroutine frame for use by other local variables.

> 通过替换 Awaiter 对象中各个操作的状态，我们可以高效的从协程那里借用内存用来为`co_await`表达式存储操作的状态。当操作第一次完成时，协程将被恢复并且 Awaiter 对象被销毁，释放协程帧用于保存其他本地变量的内存。

Ultimately, the coroutine frame may still be allocated on the heap. However, once allocated, a coroutine frame can be used to execute many asynchronous operations with only that single heap allocation.

> 当然，协程帧仍然可能分配在堆上，但是，协程帧只需要一次堆分配就能用来执行多次异步操作。

If you think about it, the coroutine frame acts as a kind of really high-performance arena memory allocator. The compiler figures out at compile time the total arena size it needs for all local variables and is then able to allocate this memory out to local variables as required with zero overhead! Try beating that with a custom allocator ;)

> 如果你想到了这点，协程帧可以用作一种高性能的区间内存分配器，编译器在编译时指出它需要为本地变量准备的总计区间大小，之后就可以无开销的分配本地变量需要的内存。尝试击败一个自定义分配器。

## An example: Implementing a simple thread-synchronisation primitive

Now that we’ve covered a lot of the mechanics of the `co_await` operator, I want to show how to put some of this knowledge into practice by implementing a basic awaitable synchronisation primitive: An asynchronous manual-reset event.

> 现在我们学习了很多关于`co_await`操作符的机制，我想通过实现一个基础的、可等待的异步原语来展示如何将知识用到实践中去，这个异步原语是一个手动重置的事件。

The basic requirements of this event is that it needs to be **Awaitable** by multiple concurrently executing coroutines and when awaited needs to suspend the awaiting coroutine until some thread calls the `.set()` method, at which point any awaiting coroutines are resumed. If some thread has already called `.set()` then the coroutine should continue without suspending.

> 这个事件的基本需求是可以被多个并发执行的协程等待，在等待时需要暂停正在等待的协程直到有线程调用了`.set()`方法，这时正在等待的协程被恢复。如果已经有线程调用了`.set()`方法，那协程应该保持运行而不会暂停。

Ideally we’d also like to make it `noexcept`, require no heap allocations and have a lock-free implementation.

> 理想的情况是我们要让他是`noexcept`的，同时不需要堆分配和锁。

**Edit 2017/11/23: Added example usage for `async_manual_reset_event`**

Example usage should look something like this:

```c++
T value;
async_manual_reset_event event;

// A single call to produce a value
void producer()
{
  value = some_long_running_computation();

  // Publish the value by setting the event.
  event.set();
}

// Supports multiple concurrent consumers
task<> consumer()
{
  // Wait until the event is signalled by call to event.set()
  // in the producer() function.
  co_await event;

  // Now it's safe to consume 'value'
  // This is guaranteed to 'happen after' assignment to 'value'
  std::cout << value << std::endl;
}
```

Let’s first think about the possible states this event can be in: ‘not set’ and ‘set’.

> 我们先来考虑这个事件有两种可能的状态：置位和未置位

When it’s in the ‘not set’ state there is a (possibly empty) list of waiting coroutines that are waiting for it to become ‘set’.

> 当它处于未置位状态时，持有一个正在等待置位的协程的列表

When it’s in the ‘set’ state there won’t be any waiting coroutines as coroutines that `co_await` the event in this state can continue without suspending.

> 当它处于置位状态时，不会有任何正在等待的协程，因为在等待这个事件的协程能继续执行而不是暂停。

This state can actually be represented in a single `std::atomic<void*>`.

> 这个状态可以用一个`std::atomic<void*>`表示

- Reserve a special pointer value for the ‘set’ state. In this case we’ll use the `this` pointer of the event since we know that can’t be the same address as any of the list items.
- Otherwise the event is in the ‘not set’ state and the value is a pointer to the head of a singly linked-list of awaiting coroutine structures.

> - 保存一个指向置位状态的指针，在这种情况下我们将使用`this`指针，因为我们知道它不可能和列表中任意一项的地址相同
> - 反之，事件处于未置位状态，它的值是个指向正在等待的协程结构的单链表的指针

We can avoid extra calls to allocate nodes for the linked-list on the heap by storing the nodes within an ‘awaiter’ object that is placed within the coroutine frame.

> 我们会避免在堆上为链表进行额外的分配调用，具体的方法是通过将节点保存在 awaiter 对象中而不是协程帧中

So let’s start with a class interface that looks something like this:

> 让我们从一个像下面这样的类接口开始：

```c++
class async_manual_reset_event
{
public:

  async_manual_reset_event(bool initiallySet = false) noexcept;

  // No copying/moving
  async_manual_reset_event(const async_manual_reset_event&) = delete;
  async_manual_reset_event(async_manual_reset_event&&) = delete;
  async_manual_reset_event& operator=(const async_manual_reset_event&) = delete;
  async_manual_reset_event& operator=(async_manual_reset_event&&) = delete;

  bool is_set() const noexcept;

  struct awaiter;
  awaiter operator co_await() const noexcept;

  void set() noexcept;
  void reset() noexcept;

private:

  friend struct awaiter;

  // - 'this' => set state
  // - otherwise => not set, head of linked list of awaiter*.
  mutable std::atomic<void*> m_state;

};
```

Here we have a fairly straight-forward and simple interface. The main thing to note at this point is that it has an `operator co_await()` method that returns an, as yet, undefined type, `awaiter`.

> 这里我们有一个相当直接和简单的接口。这里需要注意的主要事情是，它有一个`operator co_await() `方法，该方法返回一个尚未定义的类型`awaiter `。

Let’s define the `awaiter` type now.

> 让我们定义这个`awaiter`类型

### Defining the Awaiter

Firstly, it needs to know which `async_manual_reset_event` object it is going to be awaiting, so it will need a reference to the event and a constructor to initialise it.

> 首先，我得知道它要等待哪个 `async_manual_reset_event`，所以它需要一个对事件的引用并且在构造函数中初始化它。

It also needs to act as a node in a linked-list of `awaiter` values so it will need to hold a pointer to the next `awaiter` object in the list.

> 他也需要作为一个`awaiter`链表中的节点，所以它需要保存一个指向列表中下一个`awaiter`对象的指针。

It also needs to store the `coroutine_handle` of the awaiting coroutine that is executing the `co_await` expression so that the event can resume the coroutine when it becomes ‘set’. We don’t care what the promise type of the coroutine is so we’ll just use a `coroutine_handle<>` (which is short-hand for `coroutine_handle<void>`).

> 它也需要保存一个正在等待的协程的句柄，就是执行`co_await`表达式的那个协程，因此这个事件才能在变为置位状态时恢复协程。我们不需要关注协程的 promise 类型，因为我们只是使用`coroutine_handle<>`

Finally, it needs to implement the **Awaiter** interface, so it needs the three special methods: `await_ready`, `await_suspend` and `await_resume`. We don’t need to return a value from the `co_await` expression so `await_resume` can return `void`.

> 最后，他需要实现 Awaiter 接口，所以它需要实现三个指定方法：`await_ready`,，`await_suspend` 和`await_resume`。我们不需要从`co_await`表达式返回一个值，所以`await_resume`返回`void`。

Once we put all of that together, the basic class interface for `awaiter` looks like this:

> 我们把所有的东西放在一起，这个基础类看起来像下面这样：

```c++
struct async_manual_reset_event::awaiter
{
  awaiter(const async_manual_reset_event& event) noexcept
  : m_event(event)
  {}

  bool await_ready() const noexcept;
  bool await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept;
  void await_resume() noexcept {}

private:

  const async_manual_reset_event& m_event;
  std::experimental::coroutine_handle<> m_awaitingCoroutine;
  awaiter* m_next;
};
```

Now, when we `co_await` an event, we don’t want the awaiting coroutine to suspend if the event is already set. So we can define `await_ready()` to return `true` if the event is already set.

> 现在，当我们等待一个时间时，我们不想让等待的协程在事件已经置位的情况下暂停，所以我们可以定义`await_ready()`在事件已经置位的时候返回真值。

```c++
bool async_manual_reset_event::awaiter::await_ready() const noexcept
{
  return m_event.is_set();
}
```

Next, let’s look at the `await_suspend()` method. This is usually where most of the magic happens in an awaitable type.

> 接下来，让我们来看看`await_suspend()`方法，awaitable 类型中大多数魔法都发生在这里。

First it will need to stash the coroutine handle of the awaiting coroutine into the `m_awaitingCoroutine` member so that the event can later call `.resume()` on it.

> 首先，它需要把正在等待的协程的句柄存放在`m_awaitingCoroutine`成员中，事件之后就可以在它上面调用`.resume()`方法。

Then once we’ve done that we need to try and atomically enqueue the awaiter onto the linked list of waiters. If we successfully enqueue it then we return `true` to indicate that we don’t want to resume the coroutine immediately, otherwise if we find that the event has concurrently been changed to the ‘set’ state then we return `false` to indicate that the coroutine should be resumed immediately.

> 完成了这些之后，我们需要尝试原子地将等待者加入等待者列表中，如果我们成功地让它入队了，那我们就返回真值来表明我们不想让协程直接恢复，反之如果我们发现事件已经被并行地修改为了置位状态，我们就返回假值来表明这个协程应该直接恢复。

```c++
bool async_manual_reset_event::awaiter::await_suspend(
  std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
{
  // Special m_state value that indicates the event is in the 'set' state.
  const void* const setState = &m_event;

  // Remember the handle of the awaiting coroutine.
  m_awaitingCoroutine = awaitingCoroutine;

  // Try to atomically push this awaiter onto the front of the list.
  void* oldValue = m_event.m_state.load(std::memory_order_acquire);
  do
  {
    // Resume immediately if already in 'set' state.
    if (oldValue == setState) return false;

    // Update linked list to point at current head.
    m_next = static_cast<awaiter*>(oldValue);

    // Finally, try to swap the old list head, inserting this awaiter
    // as the new list head.
  } while (!m_event.m_state.compare_exchange_weak(
             oldValue,
             this,
             std::memory_order_release,
             std::memory_order_acquire));

  // Successfully enqueued. Remain suspended.
  return true;
}
```

Note that we use ‘acquire’ memory order when loading the old state so that if we read the special ‘set’ value then we have visibility of writes that occurred prior to the call to ‘set()’.

> 要注意是的我们装载旧的状态时要使用获取序，所以，如果我们读到了特定的置位值之后，我们就可以看到在调用 set 函数之前发生的写操作。

We require ‘release’ sematics if the compare-exchange succeeds so that a subsequent call to ‘set()’ will see our writes to m_awaiting Coroutine and prior writes to the coroutine state.

> 如果 CAS 操作成功的话，我们需要使用释放语义，这样后继的 set 调用就可以看到我们对于 m_awaiting 协程的写入和之前对于协程状态的写入。

### Filling out the rest of the event class

Now that we have defined the `awaiter` type, let’s go back and look at the implementation of the `async_manual_reset_event` methods.

First, the constructor. It needs to initialise to either the ‘not set’ state with the empty list of waiters (ie. `nullptr`) or initialise to the ‘set’ state (ie. `this`).

> 现在我们已经定义了`awaiter`类型，让我们回顾一下`async_manual_reset_event`方法的实现。
>
> 首先看构造函数，构造函数需要将对象初始化为以下两种：要么是未置位的状态和空的等待者列表，要么是置位状态

```c++
async_manual_reset_event::async_manual_reset_event(
  bool initiallySet) noexcept
: m_state(initiallySet ? this : nullptr)
{}
```

Next, the `is_set()` method is pretty straight-forward - it’s ‘set’ if it has the special value `this`:

> 下一步，`is_set()`方法是非常直接的——如果它有值`this`，那它就是置位状态

```c++
bool async_manual_reset_event::is_set() const noexcept
{
  return m_state.load(std::memory_order_acquire) == this;
}
```

Next, the `reset()` method. If it’s in the ‘set’ state we want to transition back to the empty-list ‘not set’ state, otherwise leave it as it is.

> 下一个是`reset()`方法，如果它处于置位状态，我们想让它变回空列表的为置位状态，否则就叫他保持原样

```c++
void async_manual_reset_event::reset() noexcept
{
  void* oldValue = this;
  m_state.compare_exchange_strong(oldValue, nullptr, std::memory_order_acquire);
}
```

With the `set()` method, we want to transition to the ‘set’ state by exchanging the current state with the special ‘set’ value, `this`, and then examine what the old value was. If there were any waiting coroutines then we want to resume each of them sequentially in turn before returning.

> 对于`set()`方法，我们想要事件变成置位状态，并通过交换当前的状态的特定的表示置位的值`this`来实现，然后检查原值是什么，如果有些正在等待的协程，接下来我们要在返回之前按顺序依次恢复它们。

```c++
void async_manual_reset_event::set() noexcept
{
  // Needs to be 'release' so that subsequent 'co_await' has
  // visibility of our prior writes.
  // Needs to be 'acquire' so that we have visibility of prior
  // writes by awaiting coroutines.
  void* oldValue = m_state.exchange(this, std::memory_order_acq_rel);
  if (oldValue != this)
  {
    // Wasn't already in 'set' state.
    // Treat old value as head of a linked-list of waiters
    // which we have now acquired and need to resume.
    auto* waiters = static_cast<awaiter*>(oldValue);
    while (waiters != nullptr)
    {
      // Read m_next before resuming the coroutine as resuming
      // the coroutine will likely destroy the awaiter object.
      auto* next = waiters->m_next;
      waiters->m_awaitingCoroutine.resume();
      waiters = next;
    }
  }
}
```

Finally, we need to implement the `operator co_await()` method. This just needs to construct an `awaiter` object.

> 最后，我们要实现`operator co_await()`方法，这仅需构造一个 `awaiter`对象

```c++
async_manual_reset_event::awaiter
async_manual_reset_event::operator co_await() const noexcept
{
  return awaiter{ *this };
}
```

And there we have it. An awaitable asynchronous manual-reset event that has a lock-free, memory-allocation-free, `noexcept` implementation.

> 我们现在已经有了一个可等待的异步 manual-reset 事件，它是无锁、无内存分配、无异常抛出的实现

If you want to have a play with the code or check out what it compiles down to under MSVC and Clang have a look at the [source on godbolt](https://godbolt.org/g/Ad47tH).

> 如果你想玩一下代码或者看看他在 MSVC 和 Clang 下被编译成了什么可以看 godbolt 上的代码。

You can also find an implementation of this class available in the [cppcoro](https://github.com/lewissbaker/cppcoro) library, along with a number of other useful awaitable types such as `async_mutex` and `async_auto_reset_event`.

> 你可以在 cppcoro 库中找到这个类的实现，也有一些其他有用的可等待类型，像`async_mutex` 和 `async_auto_reset_event`

## Closing Off

This post has looked at how the `operator co_await` is implemented and defined in terms of the **Awaitable** and **Awaiter** concepts.

> 这篇博文已经看到根据 Awaitable 和 Awaiter 的概念，`operator co_await()`是怎么实现的、如何定义的。

It has also walked through how to implement an awaitable async thread-synchronisation primitive that takes advantage of the fact that awaiter objects are allocated on the coroutine frame to avoid additional heap allocations.

> 它也展现了如何实现可等待的异步线程同步原语，这个同步原语利用了等待者对象在协程帧上分配以避免额外的堆分配这个事实。

I hope this post has helped to demystify the new `co_await` operator for you.

> 我希望这篇博文对你想明白新的`co_await`操作符有帮助。

In the next post I’ll explore the **Promise** concept and how a coroutine-type author can customise the behaviour of their coroutine.

> 在下一篇博文中我将探索 Promise 的概念以及协程类型的开发者如何自定义协程的行为。

## Thanks

I want to call out special thanks to Gor Nishanov for patiently and enthusiastically answering my many questions on coroutines over the last couple of years.

And also to Eric Niebler for reviewing and providing feedback on an early draft of this post.
