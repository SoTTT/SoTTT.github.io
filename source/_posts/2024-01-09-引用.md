---
layout: post
title: 引用
date: 2024-01-09
---

## 引言

最近写 Java，又让我反复地想起引用地一些细节。

我对“引用”的认识经过了一个长期的过程，其中包括见到各种各样的引用——Java、Python、JavaScript 中的对象引用，C++中引用修饰，C#中的引用修饰，还有抽象定义的引用传递，它们的名字和概念都涉及“引用”这两个字，但其实互不相同。因为篇幅和话题的原因，大多数学习资料总是倾向讨论它们聚焦的技术中的引用，而对于作为一个通用概念和术语的引用则少有讨论。最近我总是经常想起这些概念，所以打算将脑子中的内容整理出来，以便理解、勘误。

## 函数调用和参数传递

我学 C++要比 Java 早，学 C 又比学 C++早，在学 C 的时候，我学到要在函数中修改形参的值对于实参是没有影响的，比如：

```c
void function(int a)
{
    a = 9;
    return;
}

int number = 0;
function(number);
print("%d", number);
```

最后的输出是 0，这是因为在传递参数的时候，使用的传递方式是**值传递**，**值传递使得对形参的修改不影响实参**，事实上这就是值传递的定义；从实现角度来说，C 编译器实际上生成了代码：在 function 的栈上创建了 number 的副本，并允许在之后的代码中通过名字 a 来使用这个副本，传参结束时，a 和 number 的值相同，因为 a 是通过复制 number 的值而初始化的。

引用体现别名语义——即让形参的名字成为实参的一个别名，对应的，引用参数的定义是**引用传递使得对形参的修改影响实参**。

客观上说，C 语言不能以引用传递的方式传递参数，但是“对形参进行修改以影响实参”这种需求是存在的，C 必须有一种做法来实现之。

于是 C 选择了指针，通过指针，C 语言可以用一种稍微繁琐的写法模拟引用传递：

```c
void function(int *a)
{
    *a = 9;
    return;
}

int number = 0;
function(&number);
print("%d", number);
```

通过对 number 的**引用（reference）**操作，我们获得了 number 的地址，并传递给函数，在函数内，通过**解引用（dereference）**操作，我们获得了地址上的左值，并将新值赋给它，显然这个左值正是 number 本身，使用 number 被函数体内的语句修改了。

指针是一种广泛而强大的概念，因为它代表了访问内存资源的两个要素：数据的位置（地址）、数据的布局（类型），而在计算机中，程序使用的全部数据，包括程序的指令本身和指针本身都是内存资源，所以 C 可以用指针访问一切。这么看，通过共享地址来达成引用传递的效果就显得毫不奇怪了。

相比 C，C++更进一步，它支持原生的引用传递：

```C++
void function(int &a)
{
    a = 9;
    return;
}

int number = 0;
function(number);
print("%d", number);
```

通过`&`修饰符，C++简洁地建立了`a`和`number`的共享，不需要显式地使用引用操作和解引用操作就可以实现引用传递效果，C++引入引用的动机是运算符重载，因为有些运算符重载可能需要返回对象的左值，而引用为此提供了语法和语义支持，这对于 C++来说很重要。

C#也支持引用传递：

```c#
void function(ref int a)
{
    a = 9;
    return;
}

int number = 0;
function(ref number);
Console.WriteLine(number);
```

虽然和主题无关，但还是想提一嘴，我觉得 C#的引用语法比 C++更漂亮，也更实用；

## 引用语义

`void function(int &a) `或`void function(ref int a)`签名的意思是：“要用引用传递的方式传递 a 这个参数”，而不是“把一个引用作为参数传递过去”。

前者认为引用代表了一种传递参数的方法，与实现无关；而后者认为引用是一种类型。显然前者更符合引用传递的定义。

从这个角度来看，C#的`ref`关键字更明确；另一方面，C#要求在实参处也加上 ref 关键字，这大大提高了代码的可读性，不管从调用者还是被调者开始读都很容易知道这个参数是怎么传的（这就是我说 C#的引用语法比 C++更漂亮、也更实用的原因）。

Java 引用和引用传递的争议很大，以至于 Bruce Eckel 都叠起了甲（*On Java*对象一章）；

Java 的对象是创建在堆上的，只能通过栈上的对象引用访问它：

```java
public class Main {
    static public void main() {
        var in = new BufferedReader(new InputStreamReader(System.in));
        var s = in.readLine();
	}
}
```

对 Java 争议的核心在于当对象引用作为参数传递时到底算是值传递还是引用传递，值传递的赞成者认为通过引用确实可以修改对象的值，那就是引用传递；另一些人认为作为参数传递的是对象的引用，而非对象，而对象的引用本身是不满足引用传递定义的，故而是值传递。

其实争论到今天，大多数人已经接受 Java 只能进行值传递这件事了，其实这点还挺明显的，要进一步说明的话，我觉得这里的核心问题有两个：

- 引用是独立的类型吗？毕竟只有一个类型才有变量，只有变量才能作为参数传递；
- 对象是值语义的还是引用语义的？对引用语义的对象进行引用传递是没有意义的；

就如在讨论 C++和 C#引用语法时说到的，C++和 C#的引用在语义上更倾向于是一种修饰、对传参方式的指示而非独立类型，而 Java 不是；从这个方面来说，Java 的引用更像一种自动引用-解引用的指针，这建立在纯引用语义的对象上（如果 Java 的对象有值语义恐怕就不能这么设计了）。

我管一种类型可以使用其值的能力叫这种类型的“值作用”，对值作用的讨论涵盖了类型和语义两方面的含义。

## 值作用

就从引用本身来说，C++和 C#的引用自身是没有值作用的——它们只体现它们引用的值的值作用，这体现在 C++和 C#的引用一旦绑定就没有一种语法可以修改它的自身（将他绑定到其他值），把它放在赋值运算符左侧他就体现为它绑定的值的左值，放在右侧就表现为它绑定的值的右值，但唯独表达不了他自身的值：

```c++
int a = 0;
int &b = a;
b = 7;    //这是在修改b绑定的值，而不是重新绑定b
int c = b; //这是在访问的b绑定的值，而不是访问b
```

```c#
int a = 0;
ref int b = ref a;
b = 7;    //这是在修改b绑定的值，而不是重新绑定b
int c = b; //这是在访问的b绑定的值，而不是访问b
```

而 Java 相反，当一个对象引用出现的时候，它体现它自身的值，好像一种基本类型——可以被修改或者访问，反而是它没办法通过修改引用的语法修改对象，只能通过调用对象的方法做到这点。

```Java
Apple apple = new Apple();
Object object = new Object();

object = apple;   //重新绑定object，而不是修改object绑定的对象的值
Object object2 = object;  //访问object的值，而不是访问其绑定的对象的值
```

这个场景体现了**引用**和**对象引用**的不同：前者的值作用是透明的而后者不是，或者说在效果上前者没有值，所以很难说那是一种类型。

当然值得注意的是，C#也有对象引用，只是这里没有列举出来而已。

也有人将其归结为实现问题，他们认为反正不管那种引用都是使用指针实现的（或者说和用等效的指针写法编译结果一样），所以自然地将引用和指针混为一谈，但这是不对的，这是因为：

- 一方面，说到实现就要以标准为指导，但是实际上这几种语言都没有规定实现的细节，使用更重的句柄或将引用传递的对象隐式地扩充为响应式对象同样可以做到，选择类指针的实现，恐怕只是因为它简单、低成本；
- 另一方面，抽象是有用的，再薄的抽象也不能无视，也不能滥用；引用也是如此，如果仅从效果出发就认为引用“仅仅是一种指针”就认为抽象不存在（或者没必要存在）恐怕就是错误了。这也是为什么上面我说“Java 的引用**更像**一种自动引用-解引用的指针”而不是“Java 的引用**是**一种自动引用-解引用的指针”，从效果上讨论它们是可行的，但不可无视抽象，混为一谈。

## 标准怎么看？

上文中我从效果方面翻来覆去地分析了引用和对象引用的区别，但是那毕竟是编码者视角的区别，但是标准怎么看待它们呢？对象引用真的是一种类型吗？引用真的不是一种类型吗？

答案是无论 Java 还是 C#都没有说明对象引用是否是一种独立的类型，从语言参考的用语来看，它们似乎都将对象引用视为一种语言内部的、用于支持对象语义的机制，所以，即使在上面我们的结论是对象引用像是一种**值类型**，但是若要标准地来描述，是不能这么说的。

C++倒是明确说明了引用（例如`int&`）不是一种独立的类型，甚至不是类型，不是类型，那么自然也没法声明变量，所以在`int& a`中，a 只是一个别名而非变量，C++标准也规定引用不占内存（实现另说）。

所以看起来语言核心将引用和对象引用视为一种机制（虽然对象引用真的很想一个独立类型），至少 C++、C#和 Java 是这样的。

## 意外收获

这次查看 Java 语言参考，还有一个意外收获：在 Java 中 null 字面量是有独立类型的，且 null 是它唯一的值，它只是在需要表示为一个空的某类型对象是自动转换为该类型，所以它和任意类型都是兼容的。不过正是因为 null 的行为比较透明，所以语言参考也建议可以将无视 null 的类型而将其视为一种通用的字面量。
