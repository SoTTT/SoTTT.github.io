---
layout: post
title: 声明和定义的机制
date: 2024-03-13
---

# 声明和定义的机制

## 前言

C和C++语言有比较复杂的编译模型和结构，在C和C++中，实体的定义和声明使用分离的结构和语法，代码中对符号的使用也对其声明和定义有额外的要求，更是间接地导致了`extern`、`static`、`inline`等关键字傻傻分不清、容易用错的局面，这篇文章主要从C的历史出发，讨论C的编译模型以及声明-定义结构的动机，进而影响了编程实践和惯用法，最后说明`extern`、`static`、`inline`等几个关键字的语义变化。

## 编译模型的历史

C语言的历史和Unix的历史息息相关，1969年，Ken Thompson在一台PDP-7小型机上写出了一个分时系统原型，这个系统就是Unix的雏形；不同于现代计算机，这个机器使用18bit字长，且只支持字寻址，而不是我们现在熟知的8bit字节和字节寻址。

1971年，K.T在PDP-11小型机上重新实现了Unix，C语言的第一个编译器正是诞生在这个机器上，值得注意的是，PDP-11机器支持16bit字长，使用8bit字节寻址，这一举奠定了之后的C语言和现代处理器的道路，在C语言普及之后，8bit字节和字节寻址就成为了硬件的设计指标之一。

1972年，C语言加入了预编译器，早期的预编译器只支持`#include`和`#define`指令，主要用于支持头文件。

1973年初，C语言加入了结构体，具备了结构化地表示复合数据的能力，到这时，C语言和C语言编译模型基本定型，C语言的4步走模型：预处理、编译、汇编、链接沿用至今；笼统地说，这四步可以合称为**编译过程**。

## 预处理和声明-定义

预处理出现的最主要的动机就是支持多目标文件，早期的机器内存太小了，在为代码生成语法树时根本不可能把一个文件的语法树放在内存中，更别提同时处理多个文件，所以C语言分离了编译和链接步骤：让每一个文件单独分析，生成目标文件，在目标文件中为交叉引用的符号预留位置，再通过链接确定目标符号的实际位置；为了使用那些在其他编译单元中定义的变量和实体，C语言使用头文件用于放置实体的**声明**，这些声明用于告知编译器：“当前编译器正在使用一个其他编译单元中的定义的实体，请为这个实体的符号预留空地址，真正的地址会在稍后由链接器填写。”

与**声明**有关的另一个概念是**定义**，定义明确了实体的结构且可能在内存中产生内存对象。

不过，早期头文件中包含的只有结构体定义和变量，原因是编译器在翻译访问结构体成员时要根据结构体定义确定成员在结构体中的偏移量，也需要知道外部变量的类型和名字。但不需要声明函数，编译器的实际策略是：如果对了一个符号进行函数调用，就将其视为函数，并假设其有不定个整形类型参数并返回整形值，也就是说，保证函数参数和返回值一致的任务完全地交给了程序员。

## 定义：一种特殊的声明

在C++中，**声明**主要是为了引入一个符号，这个行为对于编译器的意义在上文已经说明过了；在很多文章中，作者总是在言语之间暗示**定义**和**声明**是对立的两个概念，但是标准告诉我们：定义实际上是种特殊的声明，其主要区别在于：声明只是引入一个符号，而定义除了符号之外，还给出了可以使用的完整结构；

具体地说：

* 对于变量：定义意味着在二进制文件或运行时的虚拟内存中存在着内存对象与这个符号对应，我们可以使用它的值；
* 对于结构体、联合体、枚举、枚举类：定义意味着程序的其它部分可以看见它们的成员和布局；
* 对于函数：意味着程序的其它部分知道它的内容和调用它时要跳转到的具体地址；

## 声明的结构

C++的声明比其它语言中的相似概念更复杂，主要是变量的行为更加复杂，声明的语义也必须更复杂，具体的来说，我将C++声明的语义总结为以下九部分：

* 作用域：由声明的上下文决定；
* 储存期：由`static`、`extern`、`auto`、`thread_local`等修饰符决定，影响变量的生命周期；
* 弱符号定义：inline；
* 链接：是否可以被其它翻译单元使用；
* 只读：变量是否可变；
* 引用：声明的是一个变量还是别名；
* 易变：变量是否对来自其它修改来源的修改可见（内存映射设备或线程）；
* 类型：无需多言；
* 名字：变量的名字；

> 对于C++这类比较复杂的语言，我的主张是在学习和教学中要时刻盯着完整的结构，许多教科书和课堂安排中，都习惯于将每个修饰词和关键字分开讲，我觉得这是不利于学习的。不仅要理解单一的修饰词的作用，也要把这个修饰词放在整个概念框架中，借助完整的概念框架建立起完整的认知，才不至于陷入只会说不会用、甚至脑子一片混乱背了忘忘了背的困境。

## 作用域

作用域概念用于指明一个变量可以在哪些范围内使用，关于作用域，一个简单的分类是将变量分为**局部变量**和**非局部变量**，声明在语法块中变量是**局部变量**，而声明在**命名空间**内的变量是**非局部变量**（全局变量属于全局命名空间）；

需要注意的是，**线程局部变量**不是**局部变量**，因为**局部变量**的**局部**指的是语法块意义上的“局部”，而**线程局部变量**的“局部”指的是线程访问意义上的局部，而从语法块意义上来说，线程局部变量既可以是局部变量也可以是非局部变量；而类的静态成员是非局部变量，因为它定义在类所属的命名空间中；

同一个变量的声明在不同的编译单元中可以有不同的作用域，最典型的情况就是一个编译单元中定义的全局变量在另一个编译单元中声明为局部变量，这是正确的。

## 储存期与链接指示关键字：extern和static

### 语义

C++标准文档中，`extern`和`static`带有**静态储存期**，也可以叫**静态生命周期**，这里的定义稍微有点反直觉，这是因为`static`本身就有“静态”的意思，这会导致一部分初学者望文生义地认为`static`表示静态生命周期而`extern`不是，但事实情况带有`static`的全局和局部变量均拥有静态生命周期。

为了区分这一点，我在下文中将被`static`修饰的变量称为**`static`变量**，而将被`static`和`extern`修饰而具有**静态储存期**的变量称为**静态储存期变量**

`static`和`extern`的真正区别在与指示了变量的**链接方式**，即它们可以在哪些翻译单元和作用域中使用，虽然从链接的角度出发，标准的规定比较琐碎，但是只看`static`和`extern`的行为就比较简单：

* 无修饰的局部变量**无链接**；
* `static`定义的全局变量表明**内部链接**；
* `extern`定义的全局变量表明**外部链接**；

### 初始化行为

#### 非局部变量

正是因为`static`和`extern`都带有**静态储存期**语义，所以被它们修饰的全局变量都适用于**静态初始化**：

##### 静态初始化

* 如果类型拥有默认初始化器或用于初始化其的表达式是常量表达式，则使用**常量初始化**；
* 如果不是，则使用**零初始化**；

需要注意的是， **静态初始化**又称为**编译时初始化**，这是因为从编译器实践的角度来讲，通常会把常量初始化的静态储存期变量放置在二进制文件的.data或.rodata段，零初始化的变量置于.bss段，在运行时访问这些变量时会直接从这两个段中访问，而不会在运行时再分配和初始化新的变量。

拥有**静态储存期**语义的全局变量的初始化是全局的，它们总是在程序入口之前初始化，这意味着这些变量是全局单例的且其初始化过程是线程安全的（因为在其初始化时整个程序只有一个线程，即主线程），这意味着全局变量本身可以充当全局单例。

线程局部变量涉及到另一个概念：**线程储存期**，顾名思义，这是**储存期**概念的一部分；

被`thread_local`修饰的变量拥有**线程储存期**，这表明它的生命周期和线程一致：作为线程初始化的一部分，它们在线程启动后，入口函数运行前被初始化。

##### 动态初始化

那些没法静态初始化的非局部变量适用于**动态初始化**，动态初始化行为更复杂，主要是因为涉及到多种不同的**次序保证**，一些特定的行为可以改变次序保证。

其中：

* 未被显式或隐式特化的类模板的静态成员和模板变量的动态初始化表现出**无序**或**局部有序**的初始化次序，其次序的变化受**线程开始**的影响；

* 除此之外的的非局部变量初始化是**有序的**，主要以**编译单元**为界，单个编译单元中的初始化严格遵守其在源代码中出现顺序；不同翻译单元中的静态变量的初始化之间是**顺序不确定**的。不同翻译单元中的线程局域变量的初始化之间是**无顺序**的。

  > **顺序不确定**和**无顺序**是有严格定义的、不同的两个概念；

#### 局部变量

局部变量也可以被`static`和`extern`修饰从而获得静态储存期，它们都在第一次被执行到时初始化，但是如果初始化过程中抛出一个异常导致了初始化失败，那么下一次执行时会再初始化，直到成功为止；

* 局部static变量初始化的线程安全性：C++17前无任何线程安全保证，C++17起保证初始化过程是线程安全的，就像`std::call_once`的行为那样。

#### 其他行为

`static`和也可以用于为类声明一个静态成员变量，使其带有**静态储存期**语义；

#### 次序保证

可以看到，非局部变量的初始化的次序保证主要是针对入口函数的：

* 非线程局部非局部变量的初始化早于**主函数**；
* 线程局部非局部变量的初始化早于**线程入口函数**；

所以，局部变量的初始化可以依赖于这些非局部变量，因为这些非局部变量在局部变量所在的函数运行前就初始化了；

但是，同为非局部变量的那些变量的初始化次序是不确定的，这种现象在动态初始化上体现的格外的显著（这主要是因为静态初始化往往不涉及互相依赖的问题），正是因为这种不确定性，所以尽量让非局部变量之间的初始化互相依赖，除非满足：

* 不是**未显式或隐式特化**的类模板的静态成员；
* 在同一个编译单元中；

#### 勘误

长期以来，我们总是混淆**static变量**和**静态储存期变量**，前者是指那些被`static`修饰的变量，后者则指所有带有**静态储存期修饰符**的变量，从定义上看前者概念更小，即**静态储存期变量**包含**static变量**；

需要注意的是，变量的声明总是有些默认的修饰符：全局变量如果没有任何修饰，那就视为被`extern`修饰着，如果局部变量没有任何储存期修饰符，就视为被`auto`修饰着；了解这种默认行为有助于理解这些修饰符：不同上下文中的声明往往带有默认的语义，而有些修饰符和某些声明的上下文是自然互斥的。

## 弱符号定义：inline

### 历史

inline这个关键字最早用于**内联指示**，编译器会尝试将标记为inline的函数调用展开为内联形式，但是随着编译器能力的上升，内联指示的作用就逐渐削弱了，到C++98（C++03）时，inline关键字已经事实上失去了**内联指示**的语义，在此之后其实际含义主要是为在头文件中定义的变量定义一个**弱符号**；到C++17时，inline的语义进一步丰富，允许使用inline来合并类的静态成员的声明和定义，进一步简化了类静态成员的写法。

### 符号和弱符号

**符号**是一个**链接概念**，在链接中，拥有链接能力的实体称为**符号**，例如函数、非局部变量等，它们的**名**就是**符号名**；

就如上一节提到的，C和C++的声明具有符号语义，一个声明要么是强的，要么是弱的，强符号严格遵循**单一定义**原则，也就是可以有多个声明，但这些声明中只有一个是实现，而弱符号可以有多个定义，编译器在最后要随机为它选择一个定义，而保证这多个定义一致的任务就被交给了程序员，也就是说，程序员可以写多个弱符号定义，但是如果这些定义不一致就是未定义行为，最后使用的是哪个定义完全取决于编译器的实现。

## 引用修饰

### 历史

最初引入引用的目的，主要是为了赋予用户创造**左值表达式**的能力，以支持特定的运算符重载。引用修饰事实上赋予了C++**引用传递**的语义，相比C使用传递指针模拟引用传递的行为这种写法更自然；

C++11之后，引用的语义变得复杂，这应该归因于**右值引用**和**万能引用**的引入，它们背后的机制是**引用折叠**，主要动机是完善C++对于移动语义的支持，而**右值转换**和**完美转发**分别是为了应对无条件右值转换和转发右值（用于模板）；

### 勘误

从C++11至今，引用对于C++初学者的误导主要有二：

* 认为某类型的引用是一种类型；
* 认为**值型别**和类型挂钩；

针对第一点，标准指出的是引用不是类型，只是一种机制，引用声明出来的也不是变量，而是一个**别名**，甚至不占内存（原则上），概念上，引用没有自己的值，当它要充当值时，总是表现它引用的对象的值；当然在如今的大多数平台上，引用是用指针实现的，但实现仍然不能改变它的标准定义；

关于第二点，主要是我经常能看见一些社区平台上有人针对“某某类型是否是左值或右值”这种问题吵得不可开交，但这个问题的根本在于值型别不是类型的属性，相反的，值型别和类型都是表达式的属性，而“左值”和“右值”正是“左值表达式”和“右值表达式”的简称，也就是说，我们只能问“某某表达式是否是左值”而不能问“某某类型是否是左值”，因为这问题本身就是错的。

## 总结

可以看出，C和C++的声明的结构是比较复杂的，这主要是因为声明和定义是分开的，为了控制声明和定义在编译和链接期的行为和语义，C++又引入了过多的概念，有些概念不太直觉；另一些则来源于C++的历史：相比其它语言C++太老了，历史包袱更大，在语言上打了太多的补丁，导致语言的结构过于复杂。

在学习C++的过程中，我更切实地感觉到对待C++这样的技术的正确的态度：一方面要认真对待，切不可用边用边学的方式去学习，毕竟C++是一门伪装成渐进语言的非渐进语言，缺乏宏观的认识容易犯错而不自知；另一方面，要客观地看待C++的历史遗产，C++是一本活历史，在学习C++中，经常会出现从技术讲到历史的情况，透过C++的一些违和之处，可以清晰的看到它背后的历史——C++和相关的技术是如何一步步发展到今天的。然而，C++的繁杂也让部分学习者（我也是其中一员）成功地走上了歧途（至少宏观地看是这样），将太多的心智浪费在那些奇怪的技法上（不是说不能学，而是在大多数情况下，它们的优先级都偏低）；这再次验证了历史的重要性——它可以帮我们分辨在庞杂的C++技术中哪些是真正精妙的设计、哪些只是特定历史背景下的妥协，而不是去鼓吹什么”最好的语言“、”真正的神“——这一直都是学习C++过程中的重要任务。

